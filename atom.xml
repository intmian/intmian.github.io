<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mian&#39;s blog</title>
  
  <subtitle>这里是mian的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-30T12:08:35.075Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode contest 121 writeup</title>
    <link href="http://yoursite.com/2019/01/28/leetcode%20121%E5%91%A8%E8%B5%9B%20writeup/"/>
    <id>http://yoursite.com/2019/01/28/leetcode 121周赛 writeup/</id>
    <published>2019-01-28T03:17:05.000Z</published>
    <updated>2019-01-30T12:08:35.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>第121周的leetcode周赛共有4题</p><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-121" target="_blank" rel="noopener">leetcode第121周周赛</a></p></blockquote><table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">知识点</th></tr></thead><tbody><tr><td style="text-align:center">不含AAA或BBB的字符串</td><td style="text-align:center">简单</td><td style="text-align:center">没有/<em>贪心</em></td></tr><tr><td style="text-align:center">基于时间的键值存储</td><td style="text-align:center">中等</td><td style="text-align:center">数据结构</td></tr><tr><td style="text-align:center">最低票价</td><td style="text-align:center">中等</td><td style="text-align:center">动态规划</td></tr><tr><td style="text-align:center">按位与为零的三元组</td><td style="text-align:center">困难</td><td style="text-align:center">数学</td></tr></tbody></table><a id="more"></a><h2 id="不含AAA或BBB的字符串"><a href="#不含AAA或BBB的字符串" class="headerlink" title="不含AAA或BBB的字符串"></a>不含AAA或BBB的字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2019/01/28/5c4eaf1c447ae.png" alt="题目"></p><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-121/problems/string-without-aaa-or-bbb/" target="_blank" rel="noopener">题目</a></p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有两种思路</p><ul><li><strong>普通思路</strong><ol><li>因为必然存在解</li><li>所以用数量少的字母隔开多的字母，使多的一方尽量<strong>均匀分配</strong>。<ul><li>例如：A = m B = n (m &gt; n)</li><li>((m / (n + 1)) <em> A B)</em>n (m / (n + 1)) * A</li></ul></li><li>因为整数除法可能出现小数，就将<strong>小数聚拢</strong><ol><li>例如 A = 5 B = 3</li><li>5 / 4 = 1.25</li><li>所以把 5 分成 1 个 2 、三个 1</li></ol></li></ol></li><li><strong>贪心算法</strong><ul><li>高射炮打蚊子了解一下</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">strWithout3a3b</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A == B)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> result;</span><br><span class="line"><span class="keyword">while</span> (A--)</span><br><span class="line">&#123;</span><br><span class="line">result.append(<span class="string">"ab"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max, min;</span><br><span class="line"><span class="keyword">char</span> max_c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> min_c = <span class="string">'b'</span>;</span><br><span class="line"><span class="built_in">string</span> result;</span><br><span class="line"><span class="keyword">if</span> (A &gt; B)</span><br><span class="line">&#123;</span><br><span class="line">max = A;</span><br><span class="line">min = B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">max = B;</span><br><span class="line">min = A;</span><br><span class="line">max_c = <span class="string">'b'</span>;</span><br><span class="line">min_c = <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num_divide_part = min + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num_1 = num_divide_part * <span class="number">2</span> - max;</span><br><span class="line"><span class="keyword">int</span> num_2 = num_divide_part - num_1;</span><br><span class="line"><span class="keyword">while</span> (num_1--)</span><br><span class="line">&#123;</span><br><span class="line">result.push_back(max_c);</span><br><span class="line">result.push_back(min_c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num_2 == <span class="number">0</span>)</span><br><span class="line">result.pop_back();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (num_2--)</span><br><span class="line">&#123;</span><br><span class="line">result.push_back(max_c); result.push_back(max_c);</span><br><span class="line">result.push_back(min_c);</span><br><span class="line">&#125;</span><br><span class="line">result.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="基于时间的键值存储"><a href="#基于时间的键值存储" class="headerlink" title="基于时间的键值存储"></a>基于时间的键值存储</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><p><a href="https://leetcode-cn.com/contest/weekly-contest-121/problems/time-based-key-value-store/" target="_blank" rel="noopener">基于时间的键值存储</a></p></blockquote><p><img src="https://i.loli.net/2019/01/28/5c4ee437186ee.png" alt="[基于时间的键值存储](https://leetcode-cn.com/contest/weekly-contest-121/problems/time-based-key-value-store/)"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用<code>map</code>和<code>unordered_map</code></p><ol><li>用<code>map</code>映射<code>key</code>到\&lt;<code>time</code>,<code>stamp</code>&gt;</li><li>用<code>unordered_map</code>映射<code>time</code>到<code>stamp</code></li></ol><p>前面用<code>map</code>的理由是保证常数级的查询时间</p><p>后面用<code>unordered_map</code>是为了尽快查出那个最大的<code>time</code>，如果使用<code>map</code>可能需要<strong>n</strong>级的时间。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">TimeMap() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; my_map;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">string</span> key, <span class="built_in">string</span> value, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (my_map.find(key) != my_map.end())</span><br><span class="line">&#123;</span><br><span class="line">my_map[key][timestamp] = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">my_map[key] = <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">my_map[key][timestamp] = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> key, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (my_map.find(key) == my_map.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;find_map = my_map[key];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = --find_map.end(); it != find_map.begin(); it--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*it).first &lt;= timestamp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (*it).second;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*find_map.begin()).first &lt;= timestamp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (*find_map.begin()).second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最低票价"><a href="#最低票价" class="headerlink" title="最低票价"></a>最低票价</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2019/01/30/5c518ea699197.png" alt="题目"></p><p><a href="https://leetcode-cn.com/contest/weekly-contest-121/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">最低票价</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>因为求得是最优化问题，而且可以分成若干个阶段，因此我们很容易想到dp。因为最低票价显然是个一元谓词，我们就设dp(n)是第n天的最低票价。</p><p>先列出<strong>状态转移</strong>方程<br>$$<br>\begin{cases}<br>dp_i = \min(dp_{i+1}+costs_0,dp_{i+7}+costs_1,dp_{i+2}+costs_{30}) &amp; i\in days \<br>dp_i = dp_{i+1}&amp;i \notin days \and i &lt; \max(days) \<br>dp_i = 0 &amp; i &gt; \max(days)<br>\end{cases}<br>$$<br>然后注意下<strong>记忆优化</strong>，避免重复的迭代展开。搞个哈希表就行(<code>unordered_map</code>)。</p><blockquote><p>不优化的话复杂度就变成O(3 ^ n)</p></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp_pre = <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; days_traval = <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="keyword">int</span> max_days;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> day, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">if</span> (dp_pre.find(day) != dp_pre.end())</span><br><span class="line"><span class="keyword">return</span> dp_pre[day];</span><br><span class="line"><span class="keyword">if</span> (day &gt; max_days)</span><br><span class="line">&#123;</span><br><span class="line">dp_pre[day] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (days_traval.find(day) == days_traval.end())</span><br><span class="line">&#123;</span><br><span class="line">result = dp(day + <span class="number">1</span>, costs);</span><br><span class="line">dp_pre[day] = result;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp; dp_datas = &#123;dp(day+<span class="number">1</span>,costs)+costs[<span class="number">0</span>],dp(day + <span class="number">7</span>,costs) + costs[<span class="number">1</span>],dp(day + <span class="number">30</span>,costs) + costs[<span class="number">2</span>]&#125;;</span><br><span class="line">result =*min_element(dp_datas.begin(), dp_datas.end());</span><br><span class="line">dp_pre[day] = result;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> day : days)</span><br><span class="line">&#123;</span><br><span class="line">days_traval.insert(day);</span><br><span class="line">&#125;</span><br><span class="line">max_days = *max_element(days.begin(),days.end());</span><br><span class="line"><span class="keyword">return</span> dp(<span class="number">1</span>,costs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="按位与为零的三元组"><a href="#按位与为零的三元组" class="headerlink" title="按位与为零的三元组"></a>按位与为零的三元组</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-121/problems/triples-with-bitwise-and-equal-to-zero/" target="_blank" rel="noopener">按位与为零的三元组</a></p><p><img src="https://i.loli.net/2019/01/30/5c519291b7c9d.png" alt="按位与为零的三元组"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这个其实是一个<strong>数论题</strong>。。。</p><p>如果<strong>硬要做还挺麻烦的</strong>，但是似乎leetcode官方没有设好时间，所以穷举也可以。。。</p><p>更好的方法就看官方的吧。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.size(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; A.size(); k++)</span><br><span class="line"><span class="keyword">if</span> ((A[i] &amp; A[j] &amp; A[k]) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次因为第一题<strong>看错题</strong>了，第三题<strong>摸鱼</strong>，导致没特别做好，就当长知识了吧-_-</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;第121周的leetcode周赛共有4题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-121&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode第121周周赛&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;题目&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;难度&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;知识点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不含AAA或BBB的字符串&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;简单&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;没有/&lt;em&gt;贪心&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;基于时间的键值存储&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;中等&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;最低票价&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;中等&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;动态规划&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;按位与为零的三元组&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;困难&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数学&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="从零开始的编程之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何重装系统</title>
    <link href="http://yoursite.com/2019/01/27/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/01/27/重装系统/</id>
    <published>2019-01-27T09:43:11.000Z</published>
    <updated>2019-01-27T11:08:30.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来我是不想写这篇文章的<del>因为懒</del>。</p><p>但是有鉴于最近<strong>找我装系统的人太多</strong>了，再加上看见小白被无良商家骗于心不忍，就写篇教程吧-_-。</p><p>我会把装机的主要几个阶段讲一下，但是任何跟着提示稍微理解下就可以无风险走的小步骤就不讲了。</p><a id="more"></a><h2 id="装系统之前的准备"><a href="#装系统之前的准备" class="headerlink" title="装系统之前的准备"></a>装系统之前的准备</h2><p>首先要有个概念 <code>装系统是一件很简单的事</code>。电脑是一件给人用的 <strong>工具</strong> ，厂商没有理由设置门槛。装机是很简单的，<strong>但是最好不要随意重装系统，文件、软件重新安置太麻烦了</strong>。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ul><li>物理准备<ul><li>一只8G以上U盘</li></ul></li><li>心理准备<ul><li>一小时不到的时间</li><li>一定的理解能力</li></ul></li></ul><h2 id="装机阶段"><a href="#装机阶段" class="headerlink" title="装机阶段"></a>装机阶段</h2><ol><li>找到你所用电脑的<strong>主板</strong>厂商（<em>不需要拆机箱，直接用aida64或者别的软件看</em>）以及<strong>型号</strong>，如果是笔记本就直接使用<strong>电脑型号</strong>。</li><li>搜索 xxxx（<em>你的主板型号</em>） 进入bios的<strong>快捷键</strong>，并记住它。</li><li>在<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">msdn 我告诉你</a>，这个网站上找到你要装的系统的 <strong>64位</strong> <strong>最新版本</strong>。</li><li>下载它。</li><li><strong>格式化</strong>U盘。</li><li>把下载的镜像文件用解压软件<strong>解压到U盘</strong>。</li><li><strong>备份c盘里的文件</strong>，其它盘看你想不想顺便格式化。</li><li>重启，并在开机的过程中<strong>狂按</strong>你记住的<strong>快捷键</strong>。</li><li>你将会进入一个蓝蓝白白的界面（bios），请动用你的英语水平进行翻译后使用。</li><li>你有两个选择<ul><li>UEFI路线<ol><li>找到<strong>boot</strong>里面的<strong>UEFI</strong>设置为<strong>ENABLE</strong></li><li><strong>重启</strong>，开机过程中<strong>狂按</strong>快捷键</li><li>会看见弹出一个<strong>对话框</strong>，选择 <strong>WINDOWS</strong> <strong>BOOT</strong> <strong>MANAGER</strong></li></ol></li><li>传统路线<ol><li>找到<strong>boot</strong>里面的<strong>启动顺序</strong></li><li>按照操作指示，把<strong>U盘</strong>放到最上面</li><li>重启</li></ol></li></ul></li><li>在Windows安装指示界面中，按照指示<strong>操作</strong>进行操作<ul><li>分区格式化请<strong>谨慎</strong></li></ul></li><li>开机后联网会<strong>自动</strong>安装驱动</li><li>在你的显卡的对应官网下载安装<strong>显卡驱动</strong></li><li>在设备管理器中查看有无设备上有<strong>感叹号标识</strong>，若有，去官网下载驱动。</li><li>是否安装<em>360</em>、<em>驱动大师</em>等软件自行判断<ul><li>我推荐ccleaner、火绒</li></ul></li><li>重启进入bios，把设置还原为改动之前的</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>简单的电脑维护其实很简单(<del>废话</del>)，只要不<strong>先入为主</strong>地认为自己不会，<strong>善用搜索引擎</strong>，不懂的东西<strong>稍微研究</strong>一下，一般都没有问题的。</p><blockquote><p>我不对任何本文后果负责，还请读者们自行判断。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来我是不想写这篇文章的&lt;del&gt;因为懒&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;但是有鉴于最近&lt;strong&gt;找我装系统的人太多&lt;/strong&gt;了，再加上看见小白被无良商家骗于心不忍，就写篇教程吧-_-。&lt;/p&gt;
&lt;p&gt;我会把装机的主要几个阶段讲一下，但是任何跟着提示稍微理解下就可以无风险走的小步骤就不讲了。&lt;/p&gt;
    
    </summary>
    
      <category term="一些小教程" scheme="http://yoursite.com/categories/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="电脑维护" scheme="http://yoursite.com/tags/%E7%94%B5%E8%84%91%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>sql中的连接</title>
    <link href="http://yoursite.com/2019/01/23/sql%20%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2019/01/23/sql 连接/</id>
    <published>2019-01-23T06:12:15.000Z</published>
    <updated>2019-01-24T10:31:54.759Z</updated>
    
    <content type="html"><![CDATA[<p>一些关于sql语句的连接的小知识</p><a id="more"></a><h1 id="为什么要用连接"><a href="#为什么要用连接" class="headerlink" title="为什么要用连接"></a>为什么要用连接</h1><h2 id="查询例子"><a href="#查询例子" class="headerlink" title="查询例子"></a>查询例子</h2><p>下面我举个例子</p><p>有这样两张表</p><p><strong>student</strong></p><table><thead><tr><th>id</th><th>name</th><th>class_id</th></tr></thead><tbody><tr><td>1</td><td>mian</td><td>1</td></tr><tr><td>2</td><td>mki</td></tr></tbody></table><p><strong>class</strong></p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>cs</td></tr><tr><td>2</td></tr></tbody></table><p>如果<strong>我们需要查询每个学生选的课</strong>，按照传统的方法我们可以</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student.name,class.name</span><br><span class="line"><span class="keyword">from</span> student,<span class="keyword">class</span></span><br><span class="line"><span class="keyword">where</span> student.class_id = class.id</span><br></pre></td></tr></table></figure><p>但是如果熟悉sql原理的同学就会知道这样的 <code>from student,class</code> 这样的语句本质上是求<br>$$<br>student \times class<br>$$<br>（笛卡尔积）</p><p>生成了这样一张表</p><table><thead><tr><th>id</th><th>name</th><th>class_id</th><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>mian</td><td>1</td><td>1</td><td>cs</td></tr><tr><td>1</td><td>mian</td><td>1</td><td>2</td><td></td></tr><tr><td>2</td><td>mki</td><td></td><td>1</td><td>cs</td></tr><tr><td>2</td><td>mki</td><td></td><td>2</td></tr></tbody></table><p>再从中选择<br>$$<br>\sigma _{student.class_id=class.id}<br>$$<br>这样子显然当student和class非常大时，查询效率太低。</p><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>既然<strong>笛卡尔迪</strong>行不通，我们就想到了我们的老朋友连接（<em>join</em>）<br>$$<br>student\Join class<br>$$<br>这样子就可以衍生出一张不比代查询的两张表大的表的。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>此处我们就应该用 <strong>join</strong> 这种sql语法</p><p>join跟据匹配生成元组的方式分为四种</p><ul><li>内连接 <em>inner join</em></li><li>左连接 <em>left join</em></li><li>右连接 <em>right join</em></li><li>全连接 <em>full join</em></li></ul><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>生成的行数为左表右表全部匹配的行</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sdudent</span><br><span class="line">inner join class</span><br><span class="line">on student.class_id = class.id</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><table><thead><tr><th>id</th><th>name</th><th>class_id</th><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>mian</td><td>1</td><td>1</td><td>cs</td></tr></tbody></table><h3 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>左表的所有元组加上匹配的右表元组</p><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sdudent</span><br><span class="line">left join class</span><br><span class="line">on student.class_id = class.id</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><table><thead><tr><th>id</th><th>name</th><th>class_id</th><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>mian</td><td>1</td><td>1</td><td>cs</td></tr><tr><td>2</td><td>mki</td><td></td><td></td></tr></tbody></table><h3 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>右表的所有元组加上匹配的左表元组</p><h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sdudent</span><br><span class="line">right join class</span><br><span class="line">on student.class_id = class.id</span><br></pre></td></tr></table></figure><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><table><thead><tr><th>id</th><th>name</th><th>class_id</th><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>mian</td><td>1</td><td>1</td><td>cs</td></tr><tr><td></td><td></td><td></td><td>2</td></tr></tbody></table><h3 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>所有左右表的元组相互匹配</p><h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sdudent</span><br><span class="line">full join class</span><br><span class="line">on student.class_id = class.id</span><br></pre></td></tr></table></figure><h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><table><thead><tr><th>id</th><th>name</th><th>class_id</th><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>mian</td><td>1</td><td>1</td><td>cs</td></tr><tr><td>2</td><td>mki</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>2</td></tr></tbody></table><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p><del>Typora 真香</del></p><p><del>Latex 真香</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些关于sql语句的连接的小知识&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的编程之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="sql" scheme="http://yoursite.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>在vs2017进行泛型模板编程的一些笔记</title>
    <link href="http://yoursite.com/2018/12/01/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/12/01/泛型/</id>
    <published>2018-12-01T12:09:00.000Z</published>
    <updated>2019-01-24T09:37:59.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我周末用<strong>c++</strong>，写数据结构的作业，出于<del>装逼</del>炫技（<del>这两个词好像没差</del>）的目的，我用<strong>oop</strong>的思想，和<strong>现代c++</strong>的语法来写作业。</p><p>其中我很自然的使用了<strong>泛型</strong>加上一些一些工程技巧。</p><p>而很遗憾的的是，当中出现了非常多的一些问题，一些是由于我对于c++的学习还不是很熟练，另一些则是因为编译器对于modern c++支持得不好，或者vs对它支持的不好。</p><a id="more"></a><h2 id="模板类中的模板类中的子类"><a href="#模板类中的模板类中的子类" class="headerlink" title="模板类中的模板类中的子类"></a>模板类中的模板类中的子类</h2><p>读上去好像有点绕口，我们举个<strong>栗子</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">O</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; ts;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    O(<span class="built_in">vector</span>&lt;T&gt; sourse)</span><br><span class="line">        :ts(sourse)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;T&gt;::itereator it = ts.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看上去没啥问题，可是一旦我们编译，就会</p><p><img src="https://i.loli.net/2018/12/01/5c0241bb7d2f8.png" alt="错误"></p><p>只是<strong>为什么</strong>呢？</p><p>因为<code>vector&lt;T&gt;::itereator</code>这段语句内，因为<code>vector&lt;T&gt;</code>是不确定的，所以我们的编译器无法确认所谓的iteratoe(注：图中的代码，单词打错了，但是不影响结果，望别介意)是<code>vector&lt;T&gt;</code>的子类还是静态变量</p><blockquote><p>注：子类这个说法是不准确的，详见stl源码</p></blockquote><p>二义性是计算机系统难以接受的，所以报错。</p><blockquote><p>至于为什么IDE不报错，又是另一个故事了</p></blockquote><p>为了消除二义性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">O</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; ts;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    O(<span class="built_in">vector</span>&lt;T&gt; sourse)</span><br><span class="line">        :ts(sourse)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::iterator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像我这样加上<code>typename</code>就可以消除二义性，声明后面的<code>iterator</code>是一个类型，而非一个变量。</p><h2 id="没有提示，没有报错"><a href="#没有提示，没有报错" class="headerlink" title="没有提示，没有报错"></a>没有提示，没有报错</h2><p>像是我们上文的代码，如果你的IDE有自动补全的话，你就会发现<code>ts.</code>这样的代码会触发自动补全而<code>vector&lt;T&gt;</code>这样的代码就不行。</p><center><img src="https://i.loli.net/2018/12/01/5c024a663c6b6.png" alt="有"></center><br><center><img src="https://i.loli.net/2018/12/01/5c024a4618fb7.png" alt="没有"></center><p>这可能有比较深的原因，但是挺坑的，就记一下吧</p><p>没有动态报错情况详见代码</p><center><img src="1.png" alt="有"></center><p>对于模板函数或者模板类内部的代码，不会进行动态检验，因此使用vs写的时候，我们的体验就回归了vc++（<del>==</del>）。</p><blockquote><p><del>至于原因，我咨询了大佬，大佬也不知道，那就凉凉喽</del></p></blockquote><h2 id="error-type的原因"><a href="#error-type的原因" class="headerlink" title="error type的原因"></a>error type的原因</h2><p>出现这种情况有两种可能</p><ul><li>参数类型写错了，这是绝大多数的情况，因为vs的类型推导十分zz，再加上没有动态检验，就会出现类型推到错误,也就是说函数的第一个参数写错了，后面的参数以及函数体里的变量都会显示error-type</li><li>类的顺序错了，不说了，太zz了</li></ul><h2 id="分离编译"><a href="#分离编译" class="headerlink" title="分离编译"></a>分离编译</h2><p>如果你恰好遇到了编译失败，原因是符号问题，那你可能是吃了分离编译的亏，因为，现在的编译器没有一个支持泛型的分离编译的。因为编译是对单个文件进行的，之后再进行链接。</p><pre><code>error LNK2019: 无法解析的外部符号 &quot;void __cdecl func&lt; int&gt;(int const &amp;)&quot; (??$func@H@@YAXABH@Z)</code></pre><p>我们来复习一下模板的实现</p><ol><li>程序员写出模板（例如模板函数）</li><li>程序员在别的地方确立对于模板的调用</li><li>编译器将模板的实例化调用符号化为符号</li><li>根据符号来生成对应符号化的模板函数</li></ol><p>也就是说当编译过程一过，编译器将不会再去实例化函数</p><p>参考一位大佬的回答</p><blockquote><p>原因出现在分离编译模式上。在分离编译模式下，func.cpp会生成一个目标文件为func.obj，由于在func.cpp文件中，并没有发生函数模板调用，所以不会将函数模板func&lt; T&gt;实例化为模板函数func&lt; int&gt;，也就是说，在func.obj中无法找到关于模板函数func&lt; int&gt;的实现代码。在源文件main.cpp中，虽然函数模板被调用，但由于没有模板代码，也不能将其实例化。也就是说，在main.obj中也找不到模板函数func&lt; int&gt;的实现代码。这样，在连接的时候就会出现func&lt; int&gt;没有定义的错误。</p></blockquote><p>所以要把函数的定义和声明放在同一个文件</p><blockquote><p>在同一个文件里进行类似调用也行，但是不推荐</p></blockquote><p><strong>和普通函数不同的是，这里不会报函数重定义的错，这是对于模板函数的特殊照顾</strong></p><h2 id="泛型的尖括号不补全"><a href="#泛型的尖括号不补全" class="headerlink" title="泛型的尖括号不补全"></a>泛型的尖括号不补全</h2><p>这问题请找罪魁祸首微软</p><h2 id="静态函数成员的一些问题"><a href="#静态函数成员的一些问题" class="headerlink" title="静态函数成员的一些问题"></a>静态函数成员的一些问题</h2><p>当我们定义一些类的静态方法时，我们会很震惊的发现，vs把静态方法的声明和下面的定义视为两个符号，而定义的函数体内，会失去绝大多数高亮补全，或者报错。而且内部的符号在vs中全部是未定义状态。而编译器最后解析的时候都是一视同仁的。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>可以考虑将定义和声明放在一起<del>，但是并没有解决实际问题23333</del></p><p>至于真正的解决方法，只有等vs更新了。</p><h2 id="模板类内双重模板与auto的推导错误"><a href="#模板类内双重模板与auto的推导错误" class="headerlink" title="模板类内双重模板与auto的推导错误"></a>模板类内双重模板与auto的推导错误</h2><p>假定有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowProcess</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;T&gt;&gt; elements, <span class="built_in">string</span> tip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> line : elements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> element : line)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照正常情况，这段代码一点问题都没有。</p><p>实际上这里会出现推导错误</p><p>line会被推导为T类型，然后雪崩</p><p>应该改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowProcess</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;T&gt;&gt; elements, <span class="built_in">string</span> tip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;T&gt; line : elements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> element : line)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我周末用&lt;strong&gt;c++&lt;/strong&gt;，写数据结构的作业，出于&lt;del&gt;装逼&lt;/del&gt;炫技（&lt;del&gt;这两个词好像没差&lt;/del&gt;）的目的，我用&lt;strong&gt;oop&lt;/strong&gt;的思想，和&lt;strong&gt;现代c++&lt;/strong&gt;的语法来写作业。&lt;/p&gt;
&lt;p&gt;其中我很自然的使用了&lt;strong&gt;泛型&lt;/strong&gt;加上一些一些工程技巧。&lt;/p&gt;
&lt;p&gt;而很遗憾的的是，当中出现了非常多的一些问题，一些是由于我对于c++的学习还不是很熟练，另一些则是因为编译器对于modern c++支持得不好，或者vs对它支持的不好。&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的编程之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>耦合与解耦</title>
    <link href="http://yoursite.com/2018/10/23/%E8%A7%A3%E8%80%A6/"/>
    <id>http://yoursite.com/2018/10/23/解耦/</id>
    <published>2018-10-23T05:58:27.000Z</published>
    <updated>2019-01-25T07:20:28.442Z</updated>
    
    <content type="html"><![CDATA[<p>高内聚，低耦合是<del>你们</del>我一直所追求的目标<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人只是个菜鸡，只是写一些自己对于架构的一些小小的理解，可能会出偏差</p><h2 id="何为耦合"><a href="#何为耦合" class="headerlink" title="何为耦合"></a>何为耦合</h2><p><strong>耦合性</strong>（英语：Coupling，dependency。或称耦合力或耦合度）是一种软件工程的度量，是指一程序中，模块及模块之间信息或参数依赖的程度。</p><p>内聚性是一个和耦合性相对的概念，一般而言低耦合性代表高内聚性，反之亦然。耦合性和内聚性都是由提出结构化设计概念的赖瑞·康斯坦丁所提出。低耦合性是结构良好程序的特性，低耦合性程序的可读性及可维护性会比较好。</p><p>看到了上面的那句话，可能会感觉概念还是有所模糊。我们毕竟是写代码的不是写文章的嘛，也就不需要说那么多没什么用的废话了。</p><p>也就是说我们的一个程序中几个<strong>不同</strong>的<strong>基本模块</strong>（可能是函数、类或者更小的基本单位）中存在着互相调用或者互相依赖的行为。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Coupling_sketches_cropped_1.svg/400px-Coupling_sketches_cropped_1.svg.png" alt="耦合"></p><h2 id="耦合的例子"><a href="#耦合的例子" class="headerlink" title="耦合的例子"></a>耦合的例子</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GetTool(<span class="string">"H_1"</span>)-&gt;add(source[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (source[<span class="number">1</span>] &gt; <span class="number">10</span>)</span><br><span class="line">        GetTool(<span class="string">"A_0"</span>)-&gt;change(source[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (source[<span class="number">1</span>] &lt; <span class="number">10</span>)</span><br><span class="line">        GetTool(<span class="string">"A_1"</span>)-&gt;change(source[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举这一个并不极端的例子，是因为<del>我编不出来了</del>这是我平时碰到的真实的问题。当我写完代码是又回头看了一眼,发现。</p><p><strong>我*</strong>。</p><p><del>他妈的</del>应该是source[2]…于是我一一把他们从1改为2。也许你们觉得这也没什么大不了的，不就是<strong>一一替换</strong>嘛，有什么大不了的。但是如果我给你个500行的复合模块，然后你把source[2]写成了source[1]，而且在函数的正确的逻辑中本来就有source[1]。那我们就不能简单的替换，而需要从头审逻辑，再改。甚至可能需要重写，这个代价就太大了。</p><p>这就是耦合的一种，<strong>过度</strong>（自己体会）使用了其他的模块的数据</p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>举个比较zz的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx_0 = xxx_0 * <span class="number">11</span> + <span class="number">1</span>;</span><br><span class="line">xxx = ToList(xxx_0);</span><br><span class="line">GetTool(<span class="string">"IDX"</span>)-&gt;add(xxx);</span><br></pre></td></tr></table></figure><p>这样的代码大家一定经常用到。有些人（<del>我</del>），经常性的将这些段落直接复制粘贴来来去去。最后在改动的时候，就需要全篇的瞎瘠薄乱改，最后浪费了巨量的时间。</p><h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><p>比方说我们有菜单类和按钮类。而按钮显然是在菜单里的。</p><p>我们现在是把按钮写死在菜单里好呢，还是各自独立好呢。</p><p>显然的，自然是同为独立类，再讲按键映射到菜单里好。因为菜单和按钮显然不是固定的关系，一个菜单拥有不定数量的按钮。如果写在一起的话，其实是很僵化的，换言之，耦合度太高，不利于维护和扩展。我们应该在菜单里以引用表的形式将按钮组合进去</p><h3 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h3><p>想必大家对于java的set、get这个段子，应该有所耳熟，可是为什么这么写呢。</p><p>主要是为了<strong>解耦</strong>。我呢，架构能力很差，就引用大佬的话来说说吧。</p><blockquote><p>很多人，并不是面向对象学得不好，但总觉得差什么，我也经历过，面向对象，封装，多态，继承，学过的人都知道，都认为自己了解了，其实不然，很多很奇妙的因素，让你误解了，大部分的人认为封装很简单，其实大错特错了，封装是最奇妙的，也是最难用好的。只要你记住以下原则，必然能很好地用好封装，成员尽量使用protected和private，不要去使用public.尽量不要提供给外部对成员属性getter的接口，意思就是不要暴露成员，为什么要这样呢？很简单，暴露成员属性必然会导致自身业务的外泄，业务外泄，会导致，类之间的无谓耦合，如A类有成员a,而程序需要对a数据改变，而你提供一个B类可以访问a成员的getter接口，B类在其自身对a修改，看上去没什么，实际上，就是类耦合，对a的修改是类A的职务，由于习惯的提供getter，导致了，在写类B的时候错误地添加了修改业务，使类A内聚能力降低，程序逐步庞大必然会越发明显，真所谓牵一发动全身，小程序确实是很难看出问题所在。</p></blockquote><h2 id="如何避免耦合"><a href="#如何避免耦合" class="headerlink" title="如何避免耦合"></a>如何避免耦合</h2><blockquote><p>我呢水平一般，只能提出一点点微小的建议</p></blockquote><ul><li>大的函数如果有可能只用到小的功能时，一定要把它分割。</li><li>如果重复的一部分反复用到的话，需要注意把它单独拿出来。</li><li>注意封装与设计模式。</li></ul><h2 id="具体实现方法"><a href="#具体实现方法" class="headerlink" title="具体实现方法"></a>具体实现方法</h2><h3 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h3><p>先看一段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(MODE mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> A:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> B:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个实际程序中的设置方法，其中MODE是一个枚举类。根据解耦的思想应该改为。<br>    void SetA(…)<br>        …<br>    void SetB(…)<br>        …<br>    …<br>    void Set(MODE mode)<br>    {<br>        switch (mode)<br>        {<br>            case A:<br>                SetA(…);<br>            case B:<br>                SetB(…);<br>            default:<br>                assert(false);<br>        }<br>    }</p><h3 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config_add = None</span><br><span class="line">def SetConfigAdd():</span><br><span class="line">    global config_add</span><br><span class="line">    config_add = xxx</span><br><span class="line">def PushSetToFile():</span><br><span class="line">    # use config_add to <span class="keyword">do</span> sth</span><br></pre></td></tr></table></figure><p>像是这样的代码就不大好，全局的设置变量是一种相当不安全、不专业的行为(<del>但是我很喜欢啊</del>)。</p><p>应该在需要出现<code>config_add</code>的最大作用域(不超过主函数)，声明config_add，把它作为<strong>引用</strong>或者<strong>常引用</strong>映射进去。(特指某些语言)</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>架构设计对于程序员要求非常高。我只学了一些皮毛，甚至有些方法都只是我自己想的。所以只做参考吧。</p><p><strong>学习！学习！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高内聚，低耦合是&lt;del&gt;你们&lt;/del&gt;我一直所追求的目标&lt;br&gt;
    
    </summary>
    
      <category term="从零开始的编程之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>关于谷歌c++编程规范</title>
    <link href="http://yoursite.com/2018/08/11/leetcode/"/>
    <id>http://yoursite.com/2018/08/11/leetcode/</id>
    <published>2018-08-11T03:17:05.000Z</published>
    <updated>2019-01-24T12:17:23.125Z</updated>
    
    <content type="html"><![CDATA[<p>良好的命名真的很重要</p><a id="more"></a><h2 id="谷歌命名规范"><a href="#谷歌命名规范" class="headerlink" title="谷歌命名规范"></a>谷歌命名规范</h2><p><strong>一个图片大纲</strong></p><div align="center"><br><img src="google.png" alt="图片大纲"><br></div><p>附上我看见过的最全面的博客</p><p><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">谷歌c++规范</a></p><h2 id="为啥不用匈牙利命名法"><a href="#为啥不用匈牙利命名法" class="headerlink" title="为啥不用匈牙利命名法"></a>为啥不用匈牙利命名法</h2><p>早期坚定拥护匈牙利命名法的Microsoft在 .NET Framework后，已经不再建议程序员使用匈牙利命名法了。</p><p>微软新的变量名称建议General Naming Conventions原文如下：</p><blockquote><p>Donot use Hungarian notation. Hungarian notation isthe practice of including a prefix in identifiers to encode some metadata aboutthe parameter, such as the data type of the identifier.</p></blockquote><p>附上一句很经典的原话：</p><blockquote><p>“避免使用匈牙利记法，它会让你的承诺落空。赘物并非信息，而是混淆耳目的伪信息。”</p></blockquote><h2 id="谷歌规范检查工具"><a href="#谷歌规范检查工具" class="headerlink" title="谷歌规范检查工具"></a>谷歌规范检查工具</h2><p>Cpplint是一个python脚本，Google使用它作为自己的C++代码规范检查工具。如果你所在的公司也使用Google C++代码规范，那么你有必要了解下Cpplint。</p><p> 下面说一下Cpplint在windows下的简单使用：</p><ol><li><p>从<a href="http://google-styleguide.googlecode.com/svn/trunk/cpplint/cpplint.py" target="_blank" rel="noopener">此处</a>下载cpplint.py源码，并将其存放到D:\soft\Cpplint\cpplint.py中；</p></li><li><p>安装python2，并将D:\ProgramFiles\Python27 添加到系统环境变量Path中；</p></li></ol><p>vs用户可以参考<a href="https://www.jianshu.com/p/64aa95820165" target="_blank" rel="noopener">这个博文</a>来进行配置。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;良好的命名真的很重要&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的编程之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>关于谷歌c++编程规范</title>
    <link href="http://yoursite.com/2018/08/11/%E5%85%B3%E4%BA%8E%E8%B0%B7%E6%AD%8Cc-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/11/关于谷歌c-编程规范的一些理解/</id>
    <published>2018-08-11T03:17:05.000Z</published>
    <updated>2019-01-24T12:17:23.125Z</updated>
    
    <content type="html"><![CDATA[<p>良好的命名真的很重要</p><a id="more"></a><h2 id="谷歌命名规范"><a href="#谷歌命名规范" class="headerlink" title="谷歌命名规范"></a>谷歌命名规范</h2><p><strong>一个图片大纲</strong></p><div align="center"><br><img src="google.png" alt="图片大纲"><br></div><p>附上我看见过的最全面的博客</p><p><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">谷歌c++规范</a></p><h2 id="为啥不用匈牙利命名法"><a href="#为啥不用匈牙利命名法" class="headerlink" title="为啥不用匈牙利命名法"></a>为啥不用匈牙利命名法</h2><p>早期坚定拥护匈牙利命名法的Microsoft在 .NET Framework后，已经不再建议程序员使用匈牙利命名法了。</p><p>微软新的变量名称建议General Naming Conventions原文如下：</p><blockquote><p>Donot use Hungarian notation. Hungarian notation isthe practice of including a prefix in identifiers to encode some metadata aboutthe parameter, such as the data type of the identifier.</p></blockquote><p>附上一句很经典的原话：</p><blockquote><p>“避免使用匈牙利记法，它会让你的承诺落空。赘物并非信息，而是混淆耳目的伪信息。”</p></blockquote><h2 id="谷歌规范检查工具"><a href="#谷歌规范检查工具" class="headerlink" title="谷歌规范检查工具"></a>谷歌规范检查工具</h2><p>Cpplint是一个python脚本，Google使用它作为自己的C++代码规范检查工具。如果你所在的公司也使用Google C++代码规范，那么你有必要了解下Cpplint。</p><p> 下面说一下Cpplint在windows下的简单使用：</p><ol><li><p>从<a href="http://google-styleguide.googlecode.com/svn/trunk/cpplint/cpplint.py" target="_blank" rel="noopener">此处</a>下载cpplint.py源码，并将其存放到D:\soft\Cpplint\cpplint.py中；</p></li><li><p>安装python2，并将D:\ProgramFiles\Python27 添加到系统环境变量Path中；</p></li></ol><p>vs用户可以参考<a href="https://www.jianshu.com/p/64aa95820165" target="_blank" rel="noopener">这个博文</a>来进行配置。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;良好的命名真的很重要&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的编程之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>hexo原生无插件快速引入图片</title>
    <link href="http://yoursite.com/2018/07/28/hexo%E5%8E%9F%E7%94%9F%E6%97%A0%E6%8F%92%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/07/28/hexo原生无插件快速引入图片/</id>
    <published>2018-07-28T09:43:11.000Z</published>
    <updated>2019-01-25T07:26:25.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>说出来你可能不信，笔者常年不知道如何在hexo里面上传图片，导致有些图片都是网上找的，不仅不稳定，时不时还会因为盗链被加入黑名单。现在说起来可真是一段血泪史啊。于是笔者看今天天气不错（<del>大雾</del>），决定搞一波图片。</p><a id="more"></a><blockquote><p>话说现在的vs-code的markdown插件可真是奇怪他竟然把我的源代码给渲染了…</p></blockquote><div align="center"><br><img src="1.png" alt="插件错误"><br></div><br>## 方法<br><br>### 传统方法<br><br>在<strong>markdown</strong>中常用的链接图片的方式是<br><br><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片描述</span>](<span class="link">图片地址</span>)</span><br></pre></td></tr></table></figure><br><br>我们要不把图片传到<strong>图床</strong>，<del><strong>要不盗链</strong></del>。<br><br>### hexo方法<br><br>#### 文件放在哪<br><br>但是我们今天用的是hexo，可以把本地的一些文件传到hexo博客在你的托管文件夹里面。<br><br>我们有两种方法<br><br><em> 传到source文件夹中然后用相对路径访问它。</em> 传到与你的markdown同名的文件夹里，然后用相对路径访问它。<br><br>毫无疑问，前一种方法存在命名空间混乱而且路径较长的问题，我们选择无视。<br><br>#### 开启自动创建文件夹<br><br>在hexo中，我们在没有hexo_gui的情况下，我们会使用<code>hexo new xxx</code>来创建md文件。<br><br>如果我们把hexo配置文件中的<code>post_asset_folder</code>选项配置为<strong>true</strong>，就可以在使用<code>new</code>命令时自动生成对应的文件夹。我们把图片放在里面就会一起上传。<br><br>#### 在hexo使用文件夹里的图片<br><br>我们依然使用<code>![]()</code>来创建图片链接。此时我们的编辑器会提示补全,以本文为例，会被补全为<br><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](hexo原生无插件快速引入图片/1.png)</span><br></pre></td></tr></table></figure><br><br>我们试着使用本地测试的方式于是我们会发现图片，在编辑器里被加载出来了，在博客中没有被加载出来，于是我们怀疑hexo在上传时改变了文件夹的结构。于是我传到了github上去试了一试，果不其然，发现图片与博客被解析到了同级文件夹中。于是正确的使用方法是<br><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](1.png)</span><br></pre></td></tr></table></figure><br><br>虽然很遗憾的是编辑器的预览里面看不见这玩意。<br><br>当然使用hexo独有的插入图片的语法也是一样，需要使用相同的技巧。<br><br>当然在我目前的3.0版本这两种语法的效果是一样的…<br><br>## 居中显示<br><br>如果一个图片比较小的话，在markdown里面直接插入是很难看的。<br><br>但是markdown支持html语法。于是我们可以把<code>![插件错误](1.png)</code>改为<br><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align=center&gt;</span><br><span class="line">![<span class="string">插件错误</span>](<span class="link">1.png</span>)</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><br><br>效果如下<br><img src="1.png" alt="插件错误"><br><br>—<br><br><div align="center"><br>    <img src="1.png" alt="插件错误"><br></div><p>当然我现在使用的编辑器并不能预览会把命令解析为文字，但在hexo中亲测可用。</p><hr><p>编辑器中，我看见的预览是↓</p><p><img src="2.png" alt="无法加载"></p><p>那也是没办法的事嘛。md普通话和方言之间确实有所差异。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;说出来你可能不信，笔者常年不知道如何在hexo里面上传图片，导致有些图片都是网上找的，不仅不稳定，时不时还会因为盗链被加入黑名单。现在说起来可真是一段血泪史啊。于是笔者看今天天气不错（&lt;del&gt;大雾&lt;/del&gt;），决定搞一波图片。&lt;/p&gt;
    
    </summary>
    
      <category term="一些小教程" scheme="http://yoursite.com/categories/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>我踩过的c++的坑</title>
    <link href="http://yoursite.com/2018/07/21/%E6%88%91%E8%B8%A9%E8%BF%87%E7%9A%84c++%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2018/07/21/我踩过的c++的坑/</id>
    <published>2018-07-21T08:28:15.000Z</published>
    <updated>2019-01-24T12:18:45.592Z</updated>
    
    <content type="html"><![CDATA[<p>c++坑还挺多的，以后每个坑我都记录下来<br>持续更新</p><a id="more"></a><h2 id="在类的实例化时不能使用其他的类的构造函数"><a href="#在类的实例化时不能使用其他的类的构造函数" class="headerlink" title="在类的实例化时不能使用其他的类的构造函数"></a>在类的实例化时不能使用其他的类的构造函数</h2><p>例如</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCHAR current_directiom[<span class="number">100</span>];</span><br><span class="line">GetCurrentDirectoryW(<span class="number">200</span>, current_directiom);</span><br><span class="line">Installer in(wstring(curren));</span><br></pre></td></tr></table></figure><p>理论上没毛病。</p><p>但是在笔者的环境中in被视为一个函数而非一个类。</p><p>必须要写成</p><pre><code>TCHAR current_directiom[100];GetCurrentDirectoryW(200, current_directiom);wstring path(current_directiom);Installer in(path);</code></pre><p>才行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> current_directiom[<span class="number">100</span>];</span><br><span class="line">GetCurrentDirectoryA(<span class="number">200</span>, current_directiom);</span><br><span class="line"><span class="built_in">string</span> path = <span class="built_in">string</span>(current_directiom) + <span class="built_in">string</span>(<span class="string">"\\data\\setting.ini"</span>);</span><br></pre></td></tr></table></figure><p>而这样的却又是可以的，迷</p><h2 id="两个指针作为参数不能重载运算符"><a href="#两个指针作为参数不能重载运算符" class="headerlink" title="两个指针作为参数不能重载运算符"></a>两个指针作为参数不能重载运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QListWidget * <span class="keyword">operator</span>&lt;&lt;(QListWidget *output, <span class="keyword">char</span>  *your_output);</span><br></pre></td></tr></table></figure><p>这样的语句是错误的,为避免出现内置类型的重载，必须有一个及以上的参数为类或枚举类型</p><h2 id="单例模式请务必加锁"><a href="#单例模式请务必加锁" class="headerlink" title="单例模式请务必加锁"></a>单例模式请务必加锁</h2><p>今天偷懒，写了一个简化版的单例模式，没加异步锁，被别人看出来了。。。</p><h2 id="别再using-namespace-std了"><a href="#别再using-namespace-std了" class="headerlink" title="别再using namespace std了"></a>别再<code>using namespace std</code>了</h2><p>这会极大的污染命名空间。很容易产生<code>c226</code>不明确问题</p><p>替代方法 <code>using xxx::yyy</code></p><blockquote><p>xxx: 命名空间<br>yyy：标识符</p></blockquote><h2 id="关于switch"><a href="#关于switch" class="headerlink" title="关于switch"></a>关于switch</h2><p>switch其实是一个流控制器。如果你用了比较传统的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> A :</span><br><span class="line">...</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>那么你在A中定义的变量会一路传下来，这是不安全的。所以会报错。</p><p>解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> A :</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>让变量超出范围就消失就行了。</p><p>如果你下文的逻辑还要用到这个变量，就把它定义到swutch块前面去。</p><h2 id="输入输出重定向的问题"><a href="#输入输出重定向的问题" class="headerlink" title="输入输出重定向的问题"></a>输入输出重定向的问题</h2><p><strong>不要在powershell中进行输入输出重定向</strong>，会报很多神奇的错误，改成cmd即可。</p><h2 id="别在迭代器中使用erase"><a href="#别在迭代器中使用erase" class="headerlink" title="别在迭代器中使用erase"></a>别在迭代器中使用erase</h2><p>例如这段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num_ptr = digits.begin(); num_ptr != digits.end(); num_ptr++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*num_ptr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        digits.erase(num_ptr);</span><br><span class="line">        digits.push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>会出现错误</p><div align="center"><br><img src="warning.png" alt="警告"><br></div><p>这段错误在<strong>STL</strong>中的源码我也放下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_Getcont() == <span class="number">0</span></span><br><span class="line">    || <span class="keyword">this</span>-&gt;_Ptr == <span class="number">0</span></span><br><span class="line">    || ((_Myvec *)<span class="keyword">this</span>-&gt;_Getcont())-&gt;_Mylast &lt;= <span class="keyword">this</span>-&gt;_Ptr)</span><br><span class="line">&#123;    <span class="comment">// report error</span></span><br><span class="line">    _DEBUG_ERROR(<span class="string">"vector iterator not incrementable"</span>);</span><br><span class="line">    _SCL_SECURE_OUT_OF_RANGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this-&gt;_Getcont()的源码是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (_Myproxy == <span class="number">0</span> ? <span class="number">0</span> : _Myproxy-&gt;_Mycont);</span><br></pre></td></tr></table></figure><p>原来的迭代器在erase后已经失效了</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>把迭代器自增分出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num_ptr = digits.begin(); num_ptr != digits.end();)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*num_ptr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num_ptr = digits.erase(num_ptr);</span><br><span class="line">        digits.push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        num_ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stl算法的前后界陷阱"><a href="#stl算法的前后界陷阱" class="headerlink" title="stl算法的前后界陷阱"></a>stl算法的前后界陷阱</h2><p>笔者在今天写代码的时候碰到了一个问题，max_element总是出错，找出来的不包括最后一个，一番研究后啼笑皆非。</p><p>我们使用这个函数对整个容器进行操作时，一定会用<code>max_element(vec.begion(),vec.end())</code>，其中的<code>end()</code>是最后一个迭代器的下一个。<br>但是我们在对容器的一部分进行操作时，却容易忘记掉，第二个参数的意义，最后导致少操作了一个。。。</p><h2 id="关于system"><a href="#关于system" class="headerlink" title="关于system"></a>关于system</h2><p>严格来说，这个不能算是c++的坑，而应该算是c语言和c++一起搞出来的的坑。</p><p><code>system</code>函数，总所周知，是不需要库的（c++），而我又好久没有写过pure c了，于是某日我在用pure c写代码时，突然发现system函数怎么命名空间里没有，而我那时恰好在给学妹演示代码，于是就变成大型翻车现场了…后来我发现，这个函数在c中其实放在<code>stdlib.h</code>里面。</p><blockquote><p>我觉得c++标准库不再需要标明.h是一个重大的创举2333</p></blockquote><h2 id="关于相对路径"><a href="#关于相对路径" class="headerlink" title="关于相对路径"></a>关于相对路径</h2><p>需要注意的是当你使用相对地址，或者使用某些库求地址的库时，其基准地址会存在陷阱。</p><p>对于代码<code>a.txt</code>按照道理你想要达成的是通过相对地址访问与程序同一个层次的<strong>a.txt</strong>。</p><ul><li>对于直接运行程序来说，你得到的就是正确的结果。</li><li>对于命令行运行的程序例如.\xxx\a.exe时，你的基准地址为命令行的工作目录，这就会导致你访问不到，或者访问了错误的a.exe。</li></ul><h2 id="关于类的定义先后"><a href="#关于类的定义先后" class="headerlink" title="关于类的定义先后"></a>关于类的定义先后</h2><p>在vs中偶遇</p><blockquote><p>error C2143: 语法错误: 缺少“;”(在“&lt;”的前面)<br>note: 参见对正在编译的类 模板 实例化“LList”的引用<br>error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int<br>error C2238: 意外的标记位于“;”之前<br>error C2143: 语法错误: 缺少“;”(在“&lt;”的前面)<br>error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int<br>error C2238: 意外的标记位于“;”之前<br>error C2143: 语法错误: 缺少“;”(在“&lt;”的前面)<br>error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int<br>error C2238: 意外的标记位于“;”之前</p></blockquote><p>这样的一大堆错误。</p><p>我当时看了很长时间都没发现错误，而且静态检测中也没报错。就是实例化后会出现类型推倒失败。我开始也以为是类的前后问题。但是因为内含类未报错。所以也就没有接着看了。</p><p>再把组合的成员声明放在总成员上后，问题就解决了。</p><p>总的来说vs，这方面的问题检验还有点问题。所以以后看到这样的错误要自己注意下LOL。</p><h2 id="有关于类多重引用的顺序"><a href="#有关于类多重引用的顺序" class="headerlink" title="有关于类多重引用的顺序"></a>有关于类多重引用的顺序</h2><p>设有A,B两类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(B b):</span><br><span class="line">    a(b.a),b(b.b)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(A a):</span><br><span class="line">    a(a.a),b(a.b)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子的代码是错误的，因为编译器是<strong>自顶而下</strong>编译的，在编译A类时，不知道B类的情况，甚至不知道B类。</p><p>那我们改一下，提前告诉编译器A类的存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(B b):</span><br><span class="line">    a(b.a),b(b.b)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(A a):</span><br><span class="line">    a(a.a),b(a.b)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子可以了吗？答案是这样子也是不行的，因为在A类中用到了<code>b.a</code>这样的东西，而编译器虽然知道B的存在，但是也就仅仅知道它的存在，换言之，这是个不完整类型。而编译器不能访问不完整类型的成员。</p><p>可以改成指针形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(B *b):</span><br><span class="line">    a(b-&gt;a),b(b-&gt;b)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(A a):</span><br><span class="line">    a(a.a),b(a.b)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子就可以解决问题了</p><p>如果你一定不要指针的话，也可以，那你可以把类内方法的实现放到两个类下面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(B *b)；</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(A a);</span><br><span class="line">&#125;</span><br><span class="line">A::A(B *b):</span><br><span class="line">    a(b-&gt;a),b(b-&gt;b)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">B::B(A a):</span><br><span class="line">    a(a.a),b(a.b)</span><br><span class="line">    &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="stl迭代器陷阱"><a href="#stl迭代器陷阱" class="headerlink" title="stl迭代器陷阱"></a>stl迭代器陷阱</h2><p>今天在用stl迭代经典算法时偶遇问题</p><blockquote><p>果然像是这种问题，还是没有成体系学习stl甚至c++的锅。</p></blockquote><pre><code>iterator not incrementablevector iterators incompatible</code></pre><p>这些问题碰到了很多次，原因这里简单记一下</p><ol><li>迭代器在容器增加，删除时很容易失效，特别是erase函数，此时就会出现不兼容错误，因为此时迭代器的行为是不可预测的。</li><li>在使用memset时很容易弄坏几个指针，就会报错</li></ol><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>不使用memset简单粗暴操作</li><li>在敏感操作后的迭代器应该重新获得，可以存储偏移，也可以使用敏感操作的返回值重新获得</li></ol><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>不再土法学习c++，继续系统化</p><h2 id="类的静态变量需要定义"><a href="#类的静态变量需要定义" class="headerlink" title="类的静态变量需要定义"></a>类的静态变量需要定义</h2><blockquote><p>符号未定义…….static…..</p></blockquote><p>如果出现这种问题，说明你没有定义类的静态变量。你至少需要在一个.cpp中定义一次</p><blockquote><p>与普通便量不同，此处不会触发重定义</p></blockquote><h2 id="命令行程序的缓冲区"><a href="#命令行程序的缓冲区" class="headerlink" title="命令行程序的缓冲区"></a>命令行程序的缓冲区</h2><p>有些人（<del>我</del>），为了程序看上去比较骚气</p><p>会使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_wsystem(<span class="string">L"title 停车 -xxxx"</span>);  <span class="comment">// 宽字节版</span></span><br><span class="line">system(<span class="string">"color F0"</span>);</span><br><span class="line">system(<span class="string">"mode con cols=36 lines=25"</span>);</span><br></pre></td></tr></table></figure><p>这样的代码。</p><p>然后我们就会发现少了一个很重要的东西，<strong>滚条</strong>。</p><p>如果一屏幕放不下就看不见上面的数据了</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line">......</span><br><span class="line">HANDLE con = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">COORD buf = &#123; <span class="number">36</span>,<span class="number">200</span> &#125;;</span><br><span class="line">SetConsoleScreenBufferSize(con, buf);</span><br></pre></td></tr></table></figure><p>使缓冲区变大</p><blockquote><p>缓冲区长度高于窗口时会有竖直的滚动条，反之反之，缓冲区应大于窗体</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c++坑还挺多的，以后每个坑我都记录下来&lt;br&gt;持续更新&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的编程之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>ROP与ROP的实践</title>
    <link href="http://yoursite.com/2018/07/15/ROP/"/>
    <id>http://yoursite.com/2018/07/15/ROP/</id>
    <published>2018-07-15T02:46:27.000Z</published>
    <updated>2018-07-30T08:13:48.518Z</updated>
    
    <content type="html"><![CDATA[<p>Return-oriented programming（<strong>ROP</strong>）是一种很常见的攻击技术，是一种具有图灵完备性的超级攻击方式。</p><a id="more"></a><h2 id="何为ROP"><a href="#何为ROP" class="headerlink" title="何为ROP"></a>何为ROP</h2><p><strong>rop</strong> 即 <strong>面向返回的编程</strong>。上文我们讲到了ret2plt，rop就是ret2plt在64位的升级版本。rop也可以用来做32位的题，是一种相当上位的攻击技术。可以替代我们之前讲的几乎所有溢出利用。可以绕过aslr与dep(NX)。</p><p>我所理解的的ROP就是有去有回，需要多次劫持程序流的攻击。</p><blockquote><p>广义的ROP包括了上文所讲到的任何返回式的攻击方式，不过我们今天要讲的是狭义的ROP</p></blockquote><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="传参方式的改变"><a href="#传参方式的改变" class="headerlink" title="传参方式的改变"></a>传参方式的改变</h3><p>在64位程序中，<a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI" target="_blank" rel="noopener">calling conventions</a>规定参数依靠寄存器传递，前面6个参数依次以rdi, rsi, rdx, rcx, r8和r9寄存来传递，后面的参数则用栈来传递。这样子我们之前的那些依靠栈来传递参数的方法似乎就难以使用。</p><h3 id="天然零化"><a href="#天然零化" class="headerlink" title="天然零化"></a>天然零化</h3><p>64位相较32位对于32位可以掌控更多（<strong>40亿</strong>倍，大约16<strong>EB</strong>）的内存。而我们显然用不到这么多内存（<del>笔者连加一条8g内存都心痛</del>），在linux中规定只使用后48位的内存，而前面的那些就全部置零，这些零字节会截断字符串，形成了天然的防护。</p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>linux x64采用了<strong>寄存器传参</strong>，因此难以使用我们平时使用的栈传参。</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">寄存器</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">RDI</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">RSI</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">RDX</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">RCX</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">R8</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">R9</td></tr></tbody></table><p>由于我们不能直接<strong>控制</strong>寄存器。</p><p>我们上文讲到的<strong>ret2plt</strong>利用所谓的PPR结构来在libc或者其他的可执行块里找到一些片段来调用。</p><p>现在我们也用这种方法来进行攻击。将我们需要执行的指令连成<strong>ROP链</strong>来进行ROP攻击。</p><hr><h2 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h2><h3 id="如何构建ROP链"><a href="#如何构建ROP链" class="headerlink" title="如何构建ROP链"></a>如何构建ROP链</h3><p>因为我们的攻击的最终目的一定是获得shell，所以我们最终需要让程序执行<code>system(&quot;\bin\sh&quot;)</code>这条指令。那就需要覆盖程序返回地址到我们想要执行的地方。</p><blockquote><p>buffer|canary|saved fame pointer|saved returned address</p></blockquote><p>那么我们需要在栈里面写入”/bin/sh\0”。因为栈的内容是我们可以控制的，所以可以写入。那么我们需要找到例如<code>pop rdi</code>这样的语句。我们可以使用诸如<strong>ROPgadget</strong>这样的工具，具体用法请看官方文档。</p><p>但是有一点需要注意，我们找到的语句必须包含一个返回<code>ret(retq)</code>，不然会顺着语句一路执行下去。</p><p>当然，我们有些时候会碰到程序过于小，导致根本没有rop片段可以利用，例如上次笔者碰见的一个500b的题，那我们需要利用libc的gadget，但是我们一般情况下不知道题目的libc，所以需要不断leak出服务器端的libc。</p><blockquote><p>如果对于libc的地址，aslr等不是很清楚的话，建议再读一读<strong>elf</strong>的内容。</p></blockquote><h2 id="ROP的功能"><a href="#ROP的功能" class="headerlink" title="ROP的功能"></a>ROP的功能</h2><p>rop看似复杂，限制很多。但是总可以从程序中找到一枝半叶，而组成极其强大的功能。<del>rop真的可以为所欲为。</del></p><p>甚至，高手的rop可以实现循环、分支、条件等等逻辑。有人指出rop具有图灵完备性。</p><hr><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><ul><li>技巧性有点强。</li><li>需要其他的栈溢出或者注入来做铺垫。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Return-oriented programming（&lt;strong&gt;ROP&lt;/strong&gt;）是一种很常见的攻击技术，是一种具有图灵完备性的超级攻击方式。&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的ctf之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>巧绕NX与ascii armoring-ret2plt</title>
    <link href="http://yoursite.com/2018/06/15/%E5%B7%A7%E7%BB%95NX%E4%B8%8Eascii-armoring-ret2plt/"/>
    <id>http://yoursite.com/2018/06/15/巧绕NX与ascii-armoring-ret2plt/</id>
    <published>2018-06-15T13:01:55.000Z</published>
    <updated>2019-01-24T05:07:05.999Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲完了plt、got，我们来个相关的。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del>前排广告位招租</del><br>最近忙于乱七八糟的事，导致没时间更博客。除了开发方面，bin方面也需要多多努力，避免被别人远远甩在后面</p><hr><h2 id="ret2plt"><a href="#ret2plt" class="headerlink" title="ret2plt"></a>ret2plt</h2><h3 id="ascii-armoring"><a href="#ascii-armoring" class="headerlink" title="ascii armoring"></a>ascii armoring</h3><p>为了针对1997年的黑客提出的 <strong>return-to-libc</strong> 技术，ascii morning被提出，以将libc的函数地址的第一个字节进行零化的方式阻止了system地址被写入栈中导致程序流被劫持到了libc中奇怪的地方，从而拿到shell。</p><blockquote><p>零字节可以截断字符串使黑客无法将system地址写入栈。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>还记得我们是怎么写shellcode的嘛，就是千方百计地通过各种方式搞出零字节。这次我们也要使用这种精神。</p><p>为了对抗ascii armoring我们不再使用libc中的函数，我们使用<strong>plt</strong>中的<strong>strcpy</strong>一点点的把system的地址拼接出来,写入plt表中的某个函数的空间中。最后再劫持程序流到这个空间中去，从而拿到shell。</p><p>这就有一个问题，我们都知道开了NX之后程序不再可以在栈中执行shellcode，这让需要执行这么多strcpy的我们感觉很麻烦。因此我们通过一种被称为 <strong>PPR</strong> 的技术，这样子我们就可以连续地执行多个函数。</p><p>PPR由两个pop、和一个ret组成，专门负责清空两个已经用过的参数（plt表中需要写入的东西与需要被写入地system地址的一部分）并且用ret返回到下一个参数中去。</p><p>假定有</p><pre><code>（堆栈中的内容）strcpy@pltsystem[0]xxx@plt[0]PPR的地址strcpy@plt &lt;--------EIP指向这里（某处）pop eax    &lt;--------PPR的地址pop eaxret</code></pre><p>我用文字来描述一般</p><ol><li>程序流走向了strcpy@plt这里后把PPR的地址当成函数的返回地址并把system[0]和xxx@plt[0]当成了函数的两个两个参数运行</li><li>执行完了strcpy后<code>ret</code>返回了某处的PPR源码中，然后通过两个<code>pop eax</code>将两个参数从栈中清除出去（通过增加了esp的值到了两个参数下面），然后通过<code>ret</code>，取出下一个strcpy的地址，并控制程序流到了那里。</li><li>返回第一过程。</li></ol><p>这样子我们就通过预先的栈溢出来控制程序的连续走向不同的plt表中的函数，来达成一个非常复杂的功能，而不是像ret-libc那样只能达成一个单独的函数的功能</p><blockquote><p>PPR技术主要是为了清除参数，在其他情况中如果没有参数则不需要PPR技术只需把下一个函数的地址填入返回地址中</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><img src="https://img-blog.csdn.net/20150801224756198" alt="payload"></p><p>我们需要从栈中注入如上图大小的块</p><p>但是我们还有几个技术问题没有解决</p><blockquote><ol><li>PPR的代码放在哪里？</li><li>strcpy在plt表中的位置</li><li>system的地址在哪里？</li><li>放在plt表的哪里</li><li>/bin/bash放在那里</li></ol></blockquote><p>我们按照一步步流程来</p><h4 id="对准EIP"><a href="#对准EIP" class="headerlink" title="对准EIP"></a>对准EIP</h4><p>这个打开ida可以解决问题或者用我们的gdb调一调也可以解决。</p><h4 id="找到strcpy的位置"><a href="#找到strcpy的位置" class="headerlink" title="找到strcpy的位置"></a>找到strcpy的位置</h4><p>可以通过ida来反编译函数来获得地址（没开aslr的情况）。</p><h4 id="找到PPR的地址"><a href="#找到PPR的地址" class="headerlink" title="找到PPR的地址"></a>找到PPR的地址</h4><p>我们唯一可以控制的空间只有栈和plt表，而对后者的控制是建立在PPR的地址已经找到了上。那我们就不能自由的注入PPR了。索性这种平衡栈帧的代码非常（<del>并不</del>）常见。我们去可执行段里随便找一个，然后拿来用。</p><h4 id="system的拷贝"><a href="#system的拷贝" class="headerlink" title="system的拷贝"></a>system的拷贝</h4><p>由于<strong>ASCII armoring</strong>机制，system的地址含有零字节，造成strcpy拷贝结束，达不到预期的攻击效果。攻击者找到4个地址空间，它的首字节分别是system地址的第一个byte, 第二个byte，第三个byte和第四个byte，然后一个个byte拷贝，将这4个byte拼凑到GOT里面。从而绕过直接拷贝system地址造成失败。</p><blockquote><p>时下最流行的<strong>ubantu</strong>没有这个特性哦。</p></blockquote><p>我们强行逆一波，然后在内存里找到，然后在记在小本本上。</p><blockquote><p>需要注意，虽然说我们都是经验<del>并不</del>丰富的攻击者，但是还需要特别注意一下，需要找的是内存中存放的字节，而不是字节的ascii码。</p></blockquote><p>也可以使用<code>find</code>命令在内存中找。为了精确定位，我们应当在内存镜像中寻找以避免地址在加载中偏移,形如<code>find /b 0xaaaaaaaa, 0xbbbbbbbb, 0xcc</code>的<strong>gdb</strong>命令可以在a…到b…的空间内写入cc。</p><blockquote><p>内存镜像的工作原理与硬盘的热备份类似，内存镜像是将内存数据做两个拷贝，分别放在主内存和镜像内存中。</p></blockquote><h4 id="写入哪个plt表空间为好呢？"><a href="#写入哪个plt表空间为好呢？" class="headerlink" title="写入哪个plt表空间为好呢？"></a>写入哪个plt表空间为好呢？</h4><p>看了我前文的内容你是否有疑惑，我用的<code>strcpy</code>并不是一个字符拷贝函数，而是字符串拷贝函数，也就是说这四个字符的位置可能会溢出，盖掉其他的plt表项，其中可能就包括strcpy。这就让我们需要选一个trycpy前面的，我就随便选个puts吧。</p><p>逆一波程序就可以拿到puts的地址了。</p><blockquote><p>本文使用了puts作为目标地址，你当然可以选择其他的。</p></blockquote><h4 id="“-bin-bash”的地址"><a href="#“-bin-bash”的地址" class="headerlink" title="“\bin\bash”的地址"></a>“\bin\bash”的地址</h4><p>同样的，为了精确攻击，我们最好找一个现成的。</p><p>Linux里面有个shell环境变量，表示前使用哪个shell，它的值通常是”/bin/bash”，如下：</p><blockquote><p>$ env | grep -i shell<br>SHELL=/bin/bash</p></blockquote><p>每个进程的环境变量都保存在主线程的栈上，因此可以在主线程栈空间上找到该字符串。由于本文的代码为单线程 ，因此可以沿着esp地址往上找即可：</p><pre><code>(gdb) x/1000s $esp…0xffffd8b4: &quot;/home/ivan/exploit/stack4&quot;0xffffd8ce: &quot;SHELL=/bin/bash&quot;0xffffd8de: &quot;TERM=xterm&quot;</code></pre><p>…</p><blockquote><p>环境变量也是作为参数传进主程序的。</p></blockquote><h4 id="攻击向量"><a href="#攻击向量" class="headerlink" title="攻击向量"></a>攻击向量</h4><p>根据上面的方法我们可以得出我们需要注入的内容。</p><p>A*x<br>strcpy@plt + PPR + puts@got[0] + addr of system[0]<br>strcpy@plt + PPR + puts@got[1] + addr of system[1]<br>strcpy@plt + PPR + puts@got[2] + addr of system[2]<br>strcpy@plt + PPR + puts@got[3] + addr of system[3]<br>puts@plt + exit + addr of “/bin/bash”</p><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><ol><li>需要确切的地址难以对抗<strong>aslr</strong>防护。</li><li>需要<strong>过于多的条件</strong>，难以满足多变的情况。</li><li>在内存中需要寻找<strong>过于多</strong>的地址。</li><li>需要注入plt表的值，在64位天然零化的情况下难以为继</li><li>与ROP技术相比，不具备完备性，局限性太强</li></ol><p>正因为许许多多的漏洞导致了ret2plt并没有流行起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面讲完了plt、got，我们来个相关的。&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的ctf之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
      <category term="plt&amp;got" scheme="http://yoursite.com/tags/plt-got/"/>
    
  </entry>
  
  <entry>
    <title>堆与最基本的堆溢出-fastbin</title>
    <link href="http://yoursite.com/2018/06/14/%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%A0%86%E6%BA%A2%E5%87%BA-fastbin/"/>
    <id>http://yoursite.com/2018/06/14/最基本的堆溢出-fastbin/</id>
    <published>2018-06-14T11:04:15.000Z</published>
    <updated>2018-07-01T07:59:13.911Z</updated>
    
    <content type="html"><![CDATA[<p>一些关于堆的小知识和基本的利用 fastbin</p><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>内存上的空间会被划分为若干个chunk</p><p>chunk包括以下两种：</p><p>已分配的堆块：</p><pre><code>     chunk-&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Size of previous chunk, if allocated            | |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Size of chunk, in bytes                       |M|P|      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             User data starts here...                          .            .                                                               .            .             (malloc_usable_size() bytes)                      .            .                                                               |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Size of chunk                                     |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>未分配的堆块：</p><pre><code>    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Size of previous chunk                            |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    `head:&apos; |             Size of chunk, in bytes                         |P|      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Forward pointer to next chunk in list             |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Back pointer to previous chunk in list            |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Unused space (may be 0 bytes long)                .            .                                                               .            .                                                               |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    `foot:&apos; |             Size of chunk, in bytes                           |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>它们的各个参数意义分别是：</p><blockquote><p>prev_size: 如果当前chunk的相邻前一chunk未被使用，prev_size为此前一chunk的大小<br>size: 当前chunk的大小。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息。我们需要记住的便是最低bit，即图中P的位置，用于指示前一chunk是否已被使用(PREV_INUSE)。</p></blockquote><blockquote><p>如果当前chunk处于未被使用状态，则mem前8 bytes被用来存储其他信息，具体如下：<br>fd: 下一个未被使用的chunk的地址<br>bk: 上一个未被使用的chunk的地址</p></blockquote><p>可以看到，chunk头中包含的大小信息，主要用来在获取内存中相邻chunk的地址（当前chunk地址减去前一chunk的大小，为前一chunk的地址；当前chunk地址加上当前chunk的大小，为后一chunk的地址）。而mem中的fd和bk只在当前chunk处于未被使用时才有意义，因为当我使用了此chunk后mem里的空间被用来存储数据。<br>通过这些未被使用的fd、bk chunk组成了一张链表。通常差不大小的chunk会被放在一起组成一张链表，其被称为bin。bin的集合被malloc合并，被称为bins。</p><p>fastbin维护一大堆的链表，当申请较小内存空间时它们会被从fastbin中剪除，并返回此地址。<br>在free时，为了快速回收这些空间，将不通过bk仅由fd将chunk插进fastbin。并且其满足后进先出的原理</p><h2 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h2><p>由于fastbin没有bk，是一个单向链表，因此可能会触发任意写的问题。</p><p>fastbin中的东西实际上是通过在内存上连续排布来实现的。当堆栈顶部的chunk被出栈以后实际上fastbin会指向次chunk的上一个。</p><p>此过程是通过fastbin中此大小的指针指向chunk的fd来实现的。所以如果fd被通过某种技术覆写，那么malloc就会返回被覆写入的地址。如果mem被丢入一个十分大的数据就会把下面的覆写了，这会导致再进行两次malloc就会返回你所定义的伪chunk中的内容。</p><p>这个伪chunk会指向你需要的任意地方，利用这种指针可以触发任意写</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些关于堆的小知识和基本的利用 fastbin&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的ctf之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="http://yoursite.com/2018/06/14/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/06/14/格式化字符串漏洞/</id>
    <published>2018-06-14T11:04:15.000Z</published>
    <updated>2019-01-24T05:07:11.082Z</updated>
    
    <content type="html"><![CDATA[<p>printf家族的格式化漏洞</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>格式化字符串漏洞主要出现在printf家族中，当程序员为了偷懒将从用户处读入的字符串直接输出时，可能会触发格式化字符串漏洞，例如以下代码。</p><pre><code>printf(&quot;%s&quot;,str)//这是安全的printf(str)//这是危险的</code></pre><p>虽然说printf的第一个参数一定会输出，但是如果在其中拥有格式字符的话，就会从堆栈中找到一个变量的参数值进行输出，从而输出本不应该输出的内容。</p><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p>以下我将把一段c++代码作为例子解析原理</p><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    char str[100];    cin &gt;&gt; str;    printf(str);    system(&quot;pause&quot;);}</code></pre><p>这段代码就会出现此类bug</p><blockquote><p>%s<br>閴J</p></blockquote><p>其中“閴J”这个奇怪的字符串就是从内存里读出来的<br>假如我们不使用%s这样的目的较纯粹的格式化字符，而是使用%n、%x这样恶意满满的格式化字符就会导致任意写或者堆栈中的东西被泄露出去。</p><h2 id="x查看栈的内容-s查看地址上的内容"><a href="#x查看栈的内容-s查看地址上的内容" class="headerlink" title="%x查看栈的内容%s查看地址上的内容"></a>%x查看栈的内容%s查看地址上的内容</h2><p>内容如下</p><blockquote><p>%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s</p></blockquote><p>-—-结果—-</p><blockquote><p>11d108211d10825b1000cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc7825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325000000000000(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)</p></blockquote><p>ps.请注意这样子操作访问的地址从高到低（堆栈从低向高利用）一个%x刚好跳过一个地址。</p><h2 id="sprint触发栈溢出"><a href="#sprint触发栈溢出" class="headerlink" title="sprint触发栈溢出"></a>sprint触发栈溢出</h2><p>例如</p><pre><code>char user[]=&quot;%496d\x39\x4a\x42\x00&quot;;char outbuf[512];char buffer[512]sprintf(buffer,&quot;ERR Wrong command：%.400s&quot;,user);</code></pre><blockquote><p>两个16进制表示一个字符，以这种方式将他们捆成整体，这样子会两个16进制会作为一个整体写入而不是作为两个字符写入毕竟我们需要在内存中写入的是00434a39而不是16个16进制。也只有以这种方式才能在内存中写入00434a39</p></blockquote><p>这里有一个小技巧利用%496d，快速向buffer里面丢垃圾这样子就往栈中存放eip的位置写入了“00434a39”</p><blockquote><p>低&emsp; 临时变量3 EBP-xxx<br>↓↓&emsp;  临时变量2 EBP-xxx<br>↓↓&emsp;  临时变量1 EBP-xxx<br>↓↓&emsp;  &lt;——EBP<br>↓↓&emsp; EBP原值<br>↓↓&emsp; EIP原值<br>↓↓&emsp; 参数1<br>↓↓&emsp; 参数2<br>高&emsp; 参数3</p></blockquote><p>调用函数附近的内存情况</p><h2 id="任意内存写"><a href="#任意内存写" class="headerlink" title="任意内存写"></a>任意内存写</h2><p>先通过这样的方式确定那个字符串放在那里<br>输入<br><code>AAAA %08x %08x %08x %08x %08x %08x %08x</code> </p><blockquote><p>\x58\x74\x04\x08%.Md%n<br>形如这样的代码可以在08047458中写入一个M+4<br>大致原理基本如此</p></blockquote><hr><p>pentools 可以很快速的进行此漏洞利用，下次有空补上</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;printf家族的格式化漏洞&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的ctf之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>unlink</title>
    <link href="http://yoursite.com/2018/06/14/unlink/"/>
    <id>http://yoursite.com/2018/06/14/unlink/</id>
    <published>2018-06-14T11:04:15.000Z</published>
    <updated>2018-07-01T07:59:13.708Z</updated>
    
    <content type="html"><![CDATA[<p>一些堆溢出方面的关于unlink的知识</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>glibc中间维护的bins其实是用来存放malloc时从heap中割下来的堆,为了避免在heap中割下了太多的连续的free chunk，系统会将free chunk自动合并到top chunk中去（top chunk指系统heap中最高位未分配的那个chunk）或者合并成为更大的一个chunk。</p><h2 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h2><p>相邻的两块chunk 一块为top chunk 一块为free chunk 或者两块两块 free chunk。所以我们要做的是先连续割两块chunk，保证他们是连续的，以保证他们会unlink。</p><blockquote><p>在溢出时之所以要覆写p位，就是为了能够触发unlink</p></blockquote><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><p>如果上一块是free chunk<br>&emsp;&emsp;合并上一块chunk并对上一块做unlink<br>如果下一块是<br>&emsp;&emsp;top：合并到top<br>&emsp;&emsp;一般chunk：<br>&emsp;&emsp;&emsp;&emsp;是free chunk：合并下一块chunk，并对下一块做unlin。最终加入unsortedbin<br>&emsp;&emsp;&emsp;&emsp;正在使用中：加入unsortedbin</p><h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>所有的同样大小的free chunk递归合并</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假定有三块连续的smallchunk<br>第一块第二块freed，第三块issued。<br>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>prevsize = 0<br>size = 0x80<br>fd = &amp;smallbin<br>bk = &amp;smallbin<br>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>prevsize = 0<br>size = 0x80<br>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>prevsize = 0<br>size = 0x81(p位+1代表上一块已经使用已经使用)<br>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></p><p>free(p)(第二块),就会导致一二两块合并，从而触发unlink<br>系统检验p+size 与p-prevsize得到了上下两个块的头</p><blockquote><p>p+0x10为FD，p+0x18为BK</p></blockquote><pre><code>unlink(P,FD,BK){    P = p    FD = P -&gt; BK    BK = P -&gt; FD    FD -&gt; BK = BK    BK -&gt; FD = FD}</code></pre><p>相当于将这个块从bin中脱链。然后系统会将上一个块更改size之类的，然后链到unsortedbin上。</p><h2 id="预期利用方式"><a href="#预期利用方式" class="headerlink" title="预期利用方式"></a>预期利用方式</h2><p>将程序劫持到shellcode中</p><blockquote><p>shellcode是一段用于利用软件漏洞而执行的代码，以其经常让攻击者获得shell而得名。 shellcode常常使用机器语言编写。</p></blockquote><p>利用unlink导致返回了weichunk中指向的地址。最后触发任意写，将必须触发的函数在got表中值改到shellcode，或者更改函数指针变量的值导致触发system()。</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路:"></a>利用思路:</h2><p>首先很直观地想到通过堆溢出q堆盖掉后面的FD和BK，将fd改为gou entry -12，将bk 改为 shellcode 的地址，将size低位改为1。在free(q)时会发生如下过程：</p><pre><code>free(q)FD = P-&gt;fd = got entry -12BK = P-&gt;bk =sc(shellcode) addrFD-&gt;bk=BK(got hijacking)got entry -12 +12 = sc addrBK-&gt;fd=FDsc addr+8=got entry -12</code></pre><p>在此过程后，会会进行一次任意写将FD+0x10的地方写入shellcode<br>然而在现实情况中，现代的glibc会有着针对chunk的检查以及其他保护机制，使得该方法无法使用。<br>因此我们的利用方式是<br>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>prevsize = 0<br>size = 0x80</p><p>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>prevsize = 0<br>size = 0x91<br>&lt; r指向此处&gt;<br>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>prevsize = 0<br>size = 0x80(p位+1代表上一块已经使用已经使用)<br>&lt; q指向此处&gt;<br>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>通过对于第二个chunk进行堆溢出将第二个块整体盖掉然后在其中伪造一个chunk并且改写第三个堆块的prev_size<br>最后变为<br>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>prevsize = 0<br>size = 0x80</p><p>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>prevsize = 0<br>size = 0x91<br>fake prev_size = 0x90&lt; r指向此处&gt;<br>fake size = 0x80<br>fake fd = &amp;r-0x18<br>fake bk = &amp;r-0x10<br>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>prevsize = 0x80<br>size = 0x80(p位+1代表上一块已经使用已经使用)<br>&lt; q指向此处&gt;<br>*<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong><br>这样子在可以绕过两个检查，成功将r并入了chunk中从而进行任意写。<br>具体流程：<br>free(q)<br>找到q与r都是freed<br>找到了最下面的q，通过q-0x10找到的prev_size。q-0x10-prev_size找到r。对于r执行unlink<br>跳过了check：<br>r-&gt;fd-&gt;bk == r = <em>(&amp;r-0x18+0x18) ==r<br>f-&gt;bk-&gt;fd == r = </em>(&amp;r-0x18+0x18) ==r</p><p>FD-&gt;bk = BK =》<em>（&amp;r-0x18+0x18）=&amp;r-0x10<br>BK-&gt;fd = FD =》</em>（&amp;r-0x10+0x10）=&amp;r-0x18</p><p>大功告成</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些堆溢出方面的关于unlink的知识&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的ctf之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>pwn的杂记</title>
    <link href="http://yoursite.com/2018/06/14/pwn%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%9A%84%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/14/pwn的小知识的杂记/</id>
    <published>2018-06-14T11:04:15.000Z</published>
    <updated>2018-07-28T01:02:02.380Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的一些pwn的随笔</p><a id="more"></a><h2 id="先讲一些关于pwn的术语吧"><a href="#先讲一些关于pwn的术语吧" class="headerlink" title="先讲一些关于pwn的术语吧"></a>先讲一些关于pwn的术语吧</h2><blockquote><ul><li><strong>payload</strong>（有效攻击负载）是包含在你用于一次漏洞利用（exploit）中的ShellCode中的主要功能代码</li><li><strong>shellcode</strong>（可提权代码） 对于一个漏洞来说，ShellCode就是一个用于某个漏洞的二进制代码框架，有了这个框架你可以在这个ShellCode中包含你需要的Payload来做一些事情</li><li><strong>exp</strong> (Exploit )漏洞利用，一般是个demo程序</li><li><strong>poc</strong>.(Proof of Concept)漏洞证明，一般就是个样本 用来证明和复现</li><li><strong>vul</strong>：(Vulnerability)  :漏洞”Pwn”：是一个黑客语法的俚语词  ，是指攻破设备或者系统</li></ul></blockquote><h2 id="gdb-peda-使用中的常用技巧"><a href="#gdb-peda-使用中的常用技巧" class="headerlink" title="gdb-peda 使用中的常用技巧"></a>gdb-peda 使用中的常用技巧</h2><p>可以使用pattern_create()创建一个形如</p><blockquote><p>pattern_create(200)<br>‘AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAnAASAAoAATAApAAUAAqAAVAArAAWAAsAAXAAtAAYAAuAAZAAvAAwA’</p></blockquote><p>的字符串，把他输入进程序就可以得到eip被误占所引发的错误。<br>再用pattern_offset 输入出错信息里的地址，就可以算出距离首地址的偏移<br>在简单的栈溢出中应当在覆盖完所有的临时变量后再顺便把bp（x86 4个 x64 8个）盖了<br>在叫完system以后会自动把其后的作为参数但是中间会需要加入参数中作为返回地址的数据（相当于传入四个字节换掉堆栈中的eip）（参数中字符串请用指针）。（当然64位中是不可以用的，因为64位中用寄存器传前七个参数）</p><p>64位自动对应p64 32位使用p32</p><blockquote><p>sh.recvuntil(‘:‘)<br>address = sh.recvuntil(‘?‘, drop=True)<br>address = int(address, 16)</p></blockquote><p>这样的方法可以获得写得起始点的地址，以确认shellcode的地址，免于重复运行计算<br>‘sadsaddas’+’asdsadsda’ == ‘saddsdsdsdsa’  ‘asdasdasda<br>checksec 可以获得保护开启情况;</p><p>break <em>0x400100 (b main):在 0x400100 处下断点<br>tb一次性断点<br>info b：查看断点信息<br>delete [number]：删除断点<br>watch </em>(int *)0x08044530：在内存0x0804453处的数据改变时stop<br>x /4xg \$ebp：查看ebp开始的4个8字节内容（b：单字节，h：双字节，w：四字节，g：八字节；x：十六进制，s：字符串输出，i：反汇编，c：单字符）<br>p $eax：输出eax的内容<br>set \$eax=4：修改变量值start<br>ls -f 可以展示隐藏文件</p><h2 id="gdb-peda常用指令（机翻）"><a href="#gdb-peda常用指令（机翻）" class="headerlink" title="gdb-peda常用指令（机翻）"></a>gdb-peda常用指令（机翻）</h2><p>c：继续运行<br>r：重新开始运行<br>ni：单步步过<br>si：单步步入<br>fini：运行至函数刚结束处<br>return expression：将函数返回值指定为expression<br>bt：查看当前栈帧<br>info f：查看当前栈帧<br>context：查看运行上下文<br>stack：查看当前堆栈<br>call func：强制函数调用<br>ropgagdet：找common rop<br>vmmap：查看虚拟地址分布<br>shellcode：搜索，生成shellcode<br>ptype struct link_map：查看link_map定义<br>p &amp;((struct link_map*)0)-&gt;l_info：查看l_info成员偏移<br>libc ：打印libc的基址<br>ld ：打印ld的基地址<br>codebase ：打印代码段的基础<br>heap ：打印堆的基础<br>got ：打印全局偏移表信息<br>dyn ：打印动态部分信息<br>findcall ：找到一些函数调用<br>bcall ：在某个函数调用中设置断点<br>tls ：打印线程本地存储地址<br>at ：按进程名称附加<br>findsyscall ：找到系统调用<br>fmtarg ：计算格式字符串的索引<br>你需要停止有漏洞的printf。<br>force ：计算力所在之处的nb。<br>heapinfo ：打印堆的一些信息<br>heapinfo（竞技场地址）<br>默认是当前线程的舞台<br>如果启用了tcache，它会显示tcache条目的信息<br>heapinfoall ：打印堆的一些信息（所有线程）<br>arenainfo ：打印所有竞技场的一些信息<br>chunkinfo：打印块的信息<br>chunkinfo（受害者的地址）<br>chunkptr ：打印块的信息<br>chunkptr（用户ptr的地址）<br>mergeinfo ：打印合并信息<br>mergeinfo（受f害者地址）<br>printfastbin ：打印fastbin的一些信息<br>tracemalloc on ：跟踪malloc并释放并检测到一些错误。<br>你需要首先运行这个进程tracemalloc on，它会记录所有的malloc和free。<br>你可以设置DEBUGpwngdb.py，比打印所有的malloc和免费的信息如screeshot。<br>parseheap ：解析堆布局<br>magic ：在glibc中打印有用的变量和函数<br>fp ：显示FILE结构<br>fp（文件的地址）<br>fpchain：显示FILE的链接列表<br>orange：中的测试house of orange条件_IO_flush_lockp<br>z() : 调出此时的调试界面<br>橙色（FILE的地址）<br>ctrl + c停止调试</p><hr><p>栈是从高向低发展<br>栈溢出是从低向高溢出<br>而单个数据内部则是从高向低按字节存放的<br>而大多数的看内存的软件则是从低向高看的</p><hr><p>ROPgadget <strong>常用</strong>指令</p><ul><li><code>binary</code></li><li><code>ropchain</code></li></ul><blockquote><p>格式： <code>ROPgadget --binary the_binary_elf ropchain</code></p></blockquote><hr><p>程序中已经用到的会被link进程序固定的<strong>plt表</strong>中</p><p>而没有被用到的也会被放在libc中，只需要无限leak即可找到system地址。</p><blockquote><p>无限leak通常出现在栈溢出可以使程序重现进入该函数。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我的一些pwn的随笔&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的ctf之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>linux上的链接</title>
    <link href="http://yoursite.com/2018/06/14/linux%E4%B8%8A%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2018/06/14/linux上的延迟重定位/</id>
    <published>2018-06-14T11:04:15.000Z</published>
    <updated>2019-01-03T12:57:24.699Z</updated>
    
    <content type="html"><![CDATA[<p>linux上的软链接与硬连接</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>按照计划我应当更新绕过NX的一些攻击方式，但是我觉得既然讲了绑定，那就顺便来讲讲有关于链接的话题吧。</p><h2 id="linux内部文件管理"><a href="#linux内部文件管理" class="headerlink" title="linux内部文件管理"></a>linux内部文件管理</h2><p>在现代操作系统中，文件的意义是使信息独立于进程长期存在。而为了方便文件被多个进程相互独立的调用，linux系统设置了一组通用的api来对文件或其他被看作文件的东西进行操作。也就是说linux把所有除了进程以外的东西全部当成文件。</p><p>文件的操作是通过所谓的字节流来进行。而上文提到的通用的api就是来管理与操作这些字节流的，最常见自然是对文件或者屏幕（终端的用户输入）进行管理的api。并且，为了方便进行管理这些文件，linux使用了文件夹这一系统。</p><blockquote><p>在linus写linux的最初版本时文件夹还不是一项必须要实现的功能，例如大名鼎鼎的unix系统就不能实现这个功能。</p></blockquote><p>如果有细心的朋友在根目录下<code>ls -a</code>,就会发现有很多文件夹</p><pre><code>/              根目录├── bin     存放用户二进制文件├── boot    存放内核引导配置文件├── dev     存放设备文件├── etc     存放系统配置文件├── home    用户主目录├── lib     动态共享库├── lost+found  文件系统恢复时的恢复文件├── media   可卸载存储介质挂载点├── mnt     文件系统临时挂载点├── opt     附加的应用程序包├── proc    系统内存的映射目录，提供内核与进程信息├── root    root 用户主目录├── sbin    存放系统二进制文件├── srv     存放服务相关数据├── sys     sys 虚拟文件系统挂载点├── tmp     存放临时文件├── usr     存放用户应用程序└── var     存放邮件、系统日志等变化文件</code></pre><p>其中的home文件夹就是我们平常所使用的最多的文件夹。</p><blockquote><p>笔者认为Linux在系统文件的隐藏，这一方面做的比windows高得多。虽然windows的文件夹目录更为直观，但是同时也产生了用户很容误删这些关键的系统文件的问题。</p><blockquote><p><del>当然windows其它方面的易用性与生态会把linux秒成渣。</del></p><blockquote><p><del>但这又有什么用呢，服务器是linux的，你还不是老老实实得需要用linux做pwn题</del></p></blockquote></blockquote></blockquote><p>需要注意的是因为万物皆为文件的设计，所以linux中的文件夹并非与windows一样，是一个高于普通文件的顶层设计的产物，而是一种特殊的文件。</p><p>使用命令 <code>mkdir</code> 创建目录时，若期望创建的目录的名称与现有的文件名（或目录名）重复，则会创建失败。</p><p>Linux 将设备当做文件进行处理下面这段终端记录展示了如何打开设备文件 /dev/input/event5 并读取文件内容。文件 event5 表示一种输入设备，其可能是鼠标或键盘等。查看文件 /proc/bus/input/devices 可知 event5 对应设备的类型。设备文件 /dev/input/event5 使用 read() 以字符流的方式被读取。结构体 input_event 被定义在内核头文件 linux/input.h 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">ie</span>;</span></span><br><span class="line">fd = open(<span class="string">"/dev/input/event5"</span>, O_RDONLY);</span><br><span class="line">read(fd, &amp;ie, <span class="keyword">sizeof</span>(struct input_event));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"type = %d  code = %d  value = %d\n"</span>,</span><br><span class="line">            ie.type, ie.code, ie.value);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>从这里可以看出设备可以作为文件来进行读写。</p><h2 id="硬链接与软链接"><a href="#硬链接与软链接" class="headerlink" title="硬链接与软链接"></a>硬链接与软链接</h2><p>虽然文件这一数据结构的作用是存放数据，但是显然，它也存放了一些与这些数据相关的另一些数据，例如创建时间，文件名等信息。</p><blockquote><p>插一些题文无关的内容，文件并不以文件名来作为系统中的唯一标识，而将文件的 <strong>inode</strong> 号作为文件的唯一标识。就和windwos系统中不以进程名而已句柄来分辨进程其实是一个道理。</p></blockquote><p>一般来说将我们将这两种数据称作</p><blockquote><ol><li>用户数据</li><li>元数据</li></ol></blockquote><p>需要注意的是，进程对于文件其实是非独占的。换言之，多个进程可以使用同一个文件。文件的共享是一个难题。可以想象，如果说没有限制的使用同一个文件会导致读取方面产生多大的问题。</p><p>为解决文件的共享使用，Linux 系统引入了两种链接：<strong>硬链接</strong> (hard link) 与 <strong>软链接</strong>（又称符号链接，即 soft link 或 symbolic link）。</p><p>链接的作用有</p><blockquote><ol><li>解决了文件的共享使用</li><li>隐藏文件路径</li><li>增加权限安全</li><li>节省存储空间</li><li>…</li></ol></blockquote><p>上文也提到了linux系统下有文件夹这一个架构，那么如果我们需要在不同的文件下同时保留一个文件，我们当然可以简单的直接拷贝一份，但是这样浪费了大量的空间，而且在程序真正需要去改变文件的数据时会导致多个文件的数据不同步，丢失了我们复制一份的初衷。</p><p>我们需要一种结构，在改变它的数据时同时会改变原始的数据，而且占用空间小。</p><p>最优的解决方案就是：</p><ul><li>只有一个真实存在的文件</li><li>在其他文件夹下存放的数据其实只是这个文件的别名。</li></ul><p>这就是 <strong>硬链接</strong> ，硬链接就是一个文件的不同的文件名。可以为一个inode号创建不同的文件名，而这些文件名可以和现实中存在文件一样被程序读写。私以为它和c++的指针特别像</p><p>当然我们也可以创建和windows中快捷方式一样的东西，这就是 <strong>软链接</strong> 。软链接是现实中存在的文件，它也有着所谓的元数据与用户数据。但是它的数据块有着些许不同，它存放的是另一个文件的地址。</p><h2 id="连接的创建"><a href="#连接的创建" class="headerlink" title="连接的创建"></a>连接的创建</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接可以用以下指令来创建</p><ol><li><code>link oldfile newfile</code></li><li><code>ln oldfile newfile</code></li></ol><p>此外需要注意，<strong>不要向目录创建硬链接</strong></p><p>但是有以下注意事项</p><blockquote><ul><li>文件有相同的 inode 及 data block；</li><li>只能对已存在的文件进行创建；</li><li>不能交叉文件系统进行硬链接的创建；</li><li>不能对目录进行创建，只可对文件创建；</li><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li></ul></blockquote><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>硬链接可以用以下指令来创建</p><ol><li><code>link -s oldfile newfile</code></li><li><code>ln -s oldfile newfile</code></li></ol><p>此外</p><blockquote><ul><li>软链接有自己的文件属性及权限等；</li><li>可对不存在的文件或目录创建软链接；</li><li>软链接可交叉文件系统；</li><li>软链接可对文件或目录创建；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）</li></ul></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>rm</code>,没啥好说的。</p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>文章拖了好久了，以后还是要多加努力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux上的软链接与硬连接&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的ctf之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux上的延迟重定位</title>
    <link href="http://yoursite.com/2018/06/14/linux-banding/"/>
    <id>http://yoursite.com/2018/06/14/linux-banding/</id>
    <published>2018-06-14T11:04:15.000Z</published>
    <updated>2018-07-01T07:59:13.708Z</updated>
    
    <content type="html"><![CDATA[<p>熟练地掌握linux的 <strong>链接</strong>与 <strong>绑定</strong>不仅仅是研究return to plt的必要，更是掌握linkmap、got表覆写、dlresolve等技术的基础</p><a id="more"></a><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul><li>plt、got表</li><li>延迟绑定</li><li>软硬链接</li></ul><h2 id="文件外函数的调用原理"><a href="#文件外函数的调用原理" class="headerlink" title="文件外函数的调用原理"></a>文件外函数的调用原理</h2><h3 id="函数调用的汇编实现"><a href="#函数调用的汇编实现" class="headerlink" title="函数调用的汇编实现"></a>函数调用的汇编实现</h3><p>假如有这样一个代码<code>system(&quot;cat flag&quot;)</code></p><p>在程序流流向这里的时候会发生什么样的事情呢？</p><p>我事先写好了一个这样的程序。让我们拖到ida里面好好看一看。</p><pre><code>push    offset command ; &quot;cat flag&quot;call    _systemadd     esp, 10h</code></pre><p>可以看见他调用了_system，这个_system和libc里面的system不是一个东西。</p><p>我们点开_system可以看见</p><pre><code>.plt:08048410 ; =============== S U B R O U T I N E =========================.plt:08048410.plt:08048410 ; Attributes: thunk.plt:08048410.plt:08048410 ; int system(const char *command).plt:08048410 _system         proc near               ; CODE XREF: main+163↓p.plt:08048410.plt:08048410 command         = dword ptr  4.plt:08048410.plt:08048410                 jmp     ds:off_804A014.plt:08048410 _system         endp.plt:08048410.plt:08048416 ; --------------------------------------------------------------</code></pre><p>我们发现了这里面有着plt三个字，这就是所谓的plt表中的一部分。</p><p>再点开</p><pre><code>ds:off_804A014</code></pre><p>我们就会发现</p><pre><code>.got.plt:0804A014 off_804A014     dd offset system        ; DATA XREF: _system↑r</code></pre><p>我们发现了这里面有着got三个字，这就是所谓的got表中的一部分。</p><h3 id="生成汇编"><a href="#生成汇编" class="headerlink" title="生成汇编"></a>生成汇编</h3><p>为什么需要有plt与got这些东西，而不在程序中直接<code>call system</code>这样的方法来访问system，的原因在于system是在glibc库中，而glibc属于动态库。</p><blockquote><p>如果读者了解过windows的动态链接库的话，事实上这两者有所区别，但是大致原理基本相似</p></blockquote><p>之所以无法直接直接<code>call system</code>，这正是用为程序中调用system的代码是在编译和链接中（事实上主要在编译中）确立的，而在此过程中，system的地址，编辑器无从而知。而在现代操作系统中，代码段也无法更改，所以试图在加载过程<code>call aaaaa</code>改为<code>call xxxxx(&amp;system)</code>也是无用功。</p><p>同时因为编辑器同时无法确定system函数是在libc这样的动态库中还是在其他的中间文件（.o）中所以编辑会生成一样格式的代码，这使得无论你的某函数是在动态链接库中还是在其它文件中给出定义，这样的汇编代码都能实现调用system。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>但是函数的调用总归是需要函数的具体地址的。那么就可以把情况分为两种。</p><blockquote><ol><li>静态链接库</li><li>动态链接库（如glibc）</li></ol></blockquote><p>在这两种情况中：</p><p>前一种函数的位置在编译过程中是已知的，所以在编译过程中可以计算出在编译过程中填进去占位的地址距离程序在被载入后此函数位置的偏移量，并将其填入某个位置。这就是 <strong>链接时重定位</strong>。</p><p>后一种函数的位置在运行时是已知的，算出偏移量中也填入此表中。这就是 <strong>运行时重定位</strong>。</p><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>在完成了重定向之后，函数的调用还面临着一个问题。那就是，在无法改变代码段的情况下，应当如何利用数据段中的偏移量呢。</p><p>答案是程序在链接中就生成一小段专门利用偏移量的代码。</p><p>链接器生成额外的伪代码如下：</p><pre><code>.text...// 调用system的call指令call system_stub...system_stub:mov rax, [system函数的储存地址] ; 获取system重定位之后的地址jmp rax ; 跳过去执行system函数.data...system函数的储存地址 ;这里储存system函数重定位后的地址</code></pre><p>在链接的过程中，如果发现函数实际上是动态链接库的代码，就会添加以上代码，并将system改为system_sub。</p><p>所以实际上在函数的调用中我们需要两样东西</p><blockquote><ul><li>需要存放外部函数的数据段</li><li>获取数据段存放函数地址，并且正确的访问他们的一小段额外代码</li></ul></blockquote><p>又因为动态库的函数往往不止一个所以许多这样的数据段与许多这样的代码形成了两张表。存储函数相对地址的表叫做 <strong>全局偏移表</strong>，即 <strong>got表</strong>,而存储那段额外的代码的表被叫做 <strong>程序链接表</strong>，即 <strong>plt表</strong>。</p><h3 id="延迟重定位"><a href="#延迟重定位" class="headerlink" title="延迟重定位"></a>延迟重定位</h3><p>前文提到了函数的地址放在got表中，所以把got中的数据段填充满必须优先于调用之前，</p><p><strong>延迟重定位</strong>，故名思意，一大特点是 <strong>延迟</strong>。</p><blockquote><p>延迟即尽可能的延迟，直到不得不执行为止。之所以linux会有这样的特性，是因为如果动态库函数非常之多，那么放在前面一起执行会大大地减弱程序的启动时间。所以linux使用延迟重定位机制来使载入动态库地时间被均匀分散到了执行时间中。</p></blockquote><p>这就产生了一个问题：程序如何知道GOT表中某一数据项是否已经被载入（因为程序中的函数可能会被执行多次，这样子就不必每一次都去重定位了）。</p><p>在程序中地具体实现大致为</p><pre><code>void system@plt(){address_good:jmp *system@got            // 链接器将system@got填成下一语句lookup_system的地址return；lookup_system:        调用重定位函数查找system地址，并写到system@got        goto address_good;}</code></pre><p>当第一次运行system函数时，程序流会跳到system@plt，然后会顺势执行jmp *system@got，但是很显然，got表中的数据项并没有填充正确的值。其实程序流并没有前往所谓的system@got，实际上它前往了lookup_system中去，这个函数的功能是调用重定位的函数来寻找system的函数地址，并将其写入system@got中去，然后再跳到addr_good，执行system然后返回到调用者。这样子下面的lookup_system就相当于被废除了。</p><p>然后在第二次调用system时，就直接走向system的真正的地址中。</p><p>事实上重定位中的最后实现并没有每一个plt中都含有符号解析与重定位的那一部分。所以程序中实现具体实现为。</p><pre><code>jmp     *system@gotpush    id(当前函数在plt中的偏移量/2)jmp     common@plt</code></pre><h3 id="公共plt的具体实现"><a href="#公共plt的具体实现" class="headerlink" title="公共plt的具体实现"></a>公共plt的具体实现</h3><p>在上文中我们基本缕清了函数重定向的前世今生与大致实现方式。接下来我要重点讲一下这个公共的函数的实现方式。</p><p>我们先在ida里看看这个函数的具体实现，在这里ida的F5已经无能为力了，我们硬刚下源码试试</p><pre><code>.plt:08048300 common          proc near               ; CODE XREF: .plt:0804831B↓j.plt:08048300                                         ; .plt:0804832B↓j ....plt:08048300 ; __unwind {.plt:08048300                 push    ds:dword_804A004.plt:08048306                 jmp     ds:dword_804A008.plt:08048306 common          endp</code></pre><p>很显然这个所谓的804A008就是所谓的重定向函数，而上面的804A004，就是参数。</p><p>而在这些地方放的就是</p><pre><code>.got.plt:0804A004 dword_804A004   dd 0                    ; DATA XREF: common↑r.got.plt:0804A008 ; int (*dword_804A008)(void).got.plt:0804A008 dword_804A008   dd 0                    ; DATA XREF: common+6↑r</code></pre><p>在下面我们发现了</p><pre><code>.got.plt:0804A00C off_804A00C     dd offset read          ; DATA XREF: _read↑r.got.plt:0804A010 off_804A010     dd offset __gmon_start__.got.plt:0804A010                                         ; DATA XREF: ___gmon_start__↑r.got.plt:0804A014 off_804A014     dd offset __libc_start_main.got.plt:0804A014                                         ; DATA XREF: ___libc_start_main↑r.got.plt:0804A018 off_804A018     dd offset write         ; DATA XREF: _write↑r.got.plt:0804A018 _got_plt        ends.got.plt:0804A018</code></pre><p>发现接着跑下去就已经看不懂了</p><p>随手点一个进去</p><pre><code>extern:0804A034                 extrn write:near        ; CODE XREF: _write↑jextern:0804A034                                         ; DATA XREF: .got.plt:off_804A018↑o</code></pre><p>好像是一个声明一样的东西。</p><p>经过了观看大神写的微博以后，我发现如果使用gdb进行动态调试的话，这个common，在没有进行运行时，其的值为0x0，在运行后会变成它的值会变成另一个值，而这个值最终指向的是 <strong>_dl_runtime_resolve</strong>,而这一个处于动态链接器中的函数。</p><h3 id="dl-runtime-resolve"><a href="#dl-runtime-resolve" class="headerlink" title="_dl_runtime_resolve"></a>_dl_runtime_resolve</h3><p>因为每一个plt表里的函数都需要调用这个公共的dlresolve项，所以dlresolve得知道需要查找的是哪一个函数，并将GOT表的值写在哪个函数的plt段。因为在plt表里push了一个参数，我上面也写了你如果去算算的话，它与函数在plt表中的偏移量相同</p><p>在程序内部，维持有一个重定位信息表。利用<code>readelf -r test</code>,可以看见.rel.plt段中的消息</p><pre><code>Offset     Info     Type             Sym.Value  Sym. Name080496f8   00000107 R_386_JUMP_SLOT  00000000   puts080496fc   00000207 R_386_JUMP_SLOT  00000000   __gmon_start__08049700   00000407 R_386_JUMP_SLOT 000000000   __libc_start_main</code></pre><p>程序可以通过这个公共的offset表，找到应当被填写GOT表函数的地址的位置。</p><blockquote><p>其实想要彻底搞清楚这个过程还需要对于elf文件在linux系统的装载有着更深的理解才行，所以我这边的讲解只是浅尝辄止不深究了。</p></blockquote><blockquote><p>日后讲解这个dlresolve的时候还会像详细讲解这个过程与可能的利用。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;熟练地掌握linux的 &lt;strong&gt;链接&lt;/strong&gt;与 &lt;strong&gt;绑定&lt;/strong&gt;不仅仅是研究return to plt的必要，更是掌握linkmap、got表覆写、dlresolve等技术的基础&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的ctf之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="plt&amp;got" scheme="http://yoursite.com/tags/plt-got/"/>
    
  </entry>
  
  <entry>
    <title>bin实用小工具</title>
    <link href="http://yoursite.com/2018/06/14/%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/06/14/实用小工具/</id>
    <published>2018-06-14T11:04:15.000Z</published>
    <updated>2018-07-01T07:59:13.708Z</updated>
    
    <content type="html"><![CDATA[<p>一些bin学习过程中常用的工具</p><a id="more"></a><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>glibc版本&lt;= 2.23</p><h2 id="bin必要工具："><a href="#bin必要工具：" class="headerlink" title="bin必要工具："></a>bin必要工具：</h2><p>Ubuntu:<br><a href="https://mirrors.aliyun.com/ubuntu-releases/16.04/" target="_blank" rel="noopener">https://mirrors.aliyun.com/ubuntu-releases/16.04/</a><br>你大可换其他的，例如kali</p><p>windows：<br>不解释</p><p>IDA7.0:<br>链接：<a href="https://pan.baidu.com/s/1s9K1TurV_bvlnWAAGJ4z-g" target="_blank" rel="noopener">https://pan.baidu.com/s/1s9K1TurV_bvlnWAAGJ4z-g</a> 密码：1e9i</p><p>没有IDA不知道怎么做bin题。。。</p><h2 id="pwn必要工具："><a href="#pwn必要工具：" class="headerlink" title="pwn必要工具："></a>pwn必要工具：</h2><p>pwntools:<br>apt-get update<br>apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential<br>pip install –upgrade pip<br>pip install –upgrade pwntools</p><p>pwn题必备，使用方法可以百度下，很容易找到的</p><p>Pwngdb:<br>链接：<a href="https://pan.baidu.com/s/1XtbuCfh_09ahlNAdly-KcA" target="_blank" rel="noopener">https://pan.baidu.com/s/1XtbuCfh_09ahlNAdly-KcA</a> 密码：mfz0</p><p>gdb的插件，简直是太好用了</p><p>msfvenom:<br><a href="https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers</a></p><p>shellcode生成工具，可以生成各种要求的shellcode，蛮好用的</p><p>roputils:<br><a href="https://github.com/inaz2/roputils" target="_blank" rel="noopener">https://github.com/inaz2/roputils</a></p><p>和pwntools一起导入可能有点问题，一开始可能用不到，我用这个做过dl-resolve的题</p><p>ROPgadget:<br><a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">https://github.com/JonathanSalwan/ROPgadget</a></p><p>ROP基本也是做pwn必备的东西，用法看自行看readme</p><h2 id="Re必要工具："><a href="#Re必要工具：" class="headerlink" title="Re必要工具："></a>Re必要工具：</h2><p>听逆向大神说好像一个IDA可以走天下了……<br>此外还需要用到OD。偶发性地，还需要一些小工具。</p><blockquote><p>建议安装吾爱破解工具包，再把里面的IDA等更新到最新版本。</p></blockquote><h2 id="小建议："><a href="#小建议：" class="headerlink" title="小建议："></a>小建议：</h2><blockquote><p>有余力的朋友建议购买正版。</p></blockquote><blockquote><p>要下载github上的东西，可以在虚拟机里输入 git clone +项目地址</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些bin学习过程中常用的工具&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的ctf之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
      <category term="re" scheme="http://yoursite.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出指南</title>
    <link href="http://yoursite.com/2018/06/14/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/06/14/栈溢出指南/</id>
    <published>2018-06-14T07:47:38.000Z</published>
    <updated>2018-07-01T07:59:13.859Z</updated>
    
    <content type="html"><![CDATA[<p>一个关于栈溢出的指南</p><a id="more"></a><h2 id="主题："><a href="#主题：" class="headerlink" title="主题："></a>主题：</h2><ul><li><p>基本栈溢出</p></li><li><p>针对缓存区溢出防护的对策</p></li></ul><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>栈溢出的最终目的是执行shellcode，夺取shell，因此本文将会从shellcode开始讲起。</p><p>shellcode通常是软件漏洞利用中的一小段代码，主要用于启动shell或干一些奇怪的事来让攻击控制正台机器</p><blockquote><p>\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb3\x01\x83\xc4\x1d\x89\xe1\xb2\x05\xb0\x04\xcd\x80\xb0\x01\xb3\x01\xfe\xcb\xcd\x80\x46\x55\x43\x4b\x0a</p></blockquote><p>这段代码的就是一段shellcode，其功能为</p><pre><code>print(&quot;fuck&quot;);return 0;</code></pre><p>当然，想要写一段shellcode也不是特别难，主要流程为</p><blockquote><p>使用c语言描述shellcode要完成的逻辑功能<br>将C语言翻译成汇编语言<br>编译和测试<br>测试通过后提取机器码</p></blockquote><p>有两个书写shellcode时需要注意的问腿</p><blockquote><p>由于缓存区漏洞是由于无长度限定的print家族（输入的是字符串，依靠’\0’(ascii码为0)结尾）造成的，所以shellcode不能有0字节，否则会被截断。<br>由于漏洞一般不能溢出无限大的字符串，所以不应该过于长。</p></blockquote><p>shellcode一般达成以下功能</p><blockquote><p>提升权限为root，即调用suid(0)<br>启开bash，全面控制系统，即调用execve(“/bin/bash, NULL, NULL);<br>打开网络端口，让攻击者连接该端口进行控制<br>反向连接攻击者提供的端口，进行反向控制。（反弹shell）</p></blockquote><h3 id="shellcode的编写"><a href="#shellcode的编写" class="headerlink" title="shellcode的编写"></a>shellcode的编写</h3><p>虽然现在到处都可以找到现成的shellcode，但是我认为到还是有必要学习shellcode的编写。</p><p>下面我将阐述关于shellcode编写构成中的小问题的解决</p><p>虽然说由于栈溢出的漏洞多半是不能在构成参数的字节里中出现0。但是很明显，在代码中多半会出现0。</p><p>例如：</p><blockquote><p>MOV eax,0<br>MOV eax,0x00000005(前三个字节都是零会把作为参数的字符串截断)</p></blockquote><p>有以下两个方法可以解决这个问题，完成寄存器清零与给寄存器赋予一个极小的数。</p><blockquote><p>xor eax eax 这样就可以将将eax置零<br>还有cld可以将edx进行置零</p></blockquote><p>如果需要将eax的值赋为0x5，不能直接写成mov eax, 0x05，因为它会生成机器码mov eax, 0x00000005，会有0填充（因为一个字节只能有8位你丢进去了32位那自然会有数据为零的内存基本单元出现）。</p><p>可以采用下面这个技巧：</p><blockquote><p>xor eax, eax<br>mov al, 0x05</p></blockquote><p>虽然说在有些情况下，我们可以知道shellcode的绝对地址，从而跳转到shellcode处，但是在有些情况下shellcode中shellcode的位置是会变化的，这导致了shellcode所要填写的地址难以确定。但是我们可以使用另一个技巧来进行处理。<br>例如call技术：<br>call指令是相对转跳，但会在栈上压上绝对地址，然后再弹出就可以获取绝对地址</p><pre><code>jmp short get_stringcode:       pop eax            ; 这里弹出的是call指令压栈的下条指令的地址，即&quot;hello world&quot;字符串的地址get_string:      call codedata:db &apos;hello world&apos;, 0x0a</code></pre><p>linux系统调用是通过 int 0x80来陷入内核态的，在此过程中系统调用号通过eax来传递，而参数则是通过ebx，ecx,edx，esi来传递的。</p><p>在补充了这些基础知识后我们开始真正的着手开始编写shellcode,可以直接使用gcc对汇编文件.S进行编译链接，生成标准的可执行ELF文件，同时也是直接进行测试，但又一点不方便的是提取机械码很不方便。</p><p>为了提高提取机械码的效率，nasm编译器生成bin格式文件，而且没有其他东西，棒棒哒</p><p>例如我们想要书写一个夺取shell的shellcode，我们需要书写的核心代码是</p><pre><code>char *argv[2];argv[0] = &quot;/bin/sh&quot;;argv[1] = NULL;//指针数组需要以NULL结束不然会接着寻找接下去的指针execve(&quot;/bin/sh&quot;, argv, NULL);//execve是内核级系统调用，第二个参数为数组指针，第三个参数为新的环境变量</code></pre><blockquote><p>excve的系统调用号为11</p></blockquote><p>接下来我们将会将其转化为汇编代码（需要注意寄存器传参这一情况）<br>先将字符串压到栈上</p><pre><code>xor edx, edxpush edxpush 0x68732f2fpush 0x6e69622f</code></pre><p>这样子压入了”/bin/sh”，应该注意因为地址是从高地址向低地址蔓延的，所以需要从字符串的尾巴开始压起。</p><blockquote><p>字符串在内存中的分布如下<br>低 结束’\0’<br>↑↑ 第三部分<br>↑↑ 第二部分<br>高 第一部分<br>换言之，栈顶指向的永远是一块数据的开始</p></blockquote><blockquote><p>由于我们需要让shellocde尽可能的短，所以我们不需要将没用的数据从堆栈中拿出，只需要简单的弃用就可以了</p></blockquote><p>紧接着将这个字符串的指针也就是现在的栈顶取出,并压入栈中</p><pre><code>mov ebx,esppush ebx</code></pre><p>由于我们前面所对edx做的操作使得edx的值是0（即NULL）所以只需要</p><pre><code>push edx</code></pre><p>就把argv的数据全放在栈里了，然后</p><pre><code>mov ecx,esp</code></pre><p>最后把系统调用号即11赋给eax</p><pre><code>xor eax eaxmov al 0xb</code></pre><p>这样操作过后，eax为系统调用号，ebx为“/bin/sh”，ecx为argv，edx为新的环境变量，大功告成，紧接着我们</p><pre><code>int 0x80</code></pre><p>进行系统调用，大功告成。拼接过后的代码为</p><pre><code>BITS 32  xor edx, edx  push edx  push 0x68732f2f  push 0x6e69622f  mov ebx, esp  push edx  push ebx  mov ecx, esp  xor eax, eax  mov al, 0xb  int 0x80  </code></pre><p>编译生成机器码</p><pre><code>nasm -o shell2 shell2.s</code></pre><p>生成的shell2文件为bin数据，全是机器码，没有任何格式数据，使用Linux命令转换成bash或者perl可输入的shellcode.</p><pre><code>$ od -t x1 shell2 | sed -e &apos;s/[0-7]*//&apos; | sed -e &apos;s/ /\\x/g&apos;</code></pre><p>得到</p><blockquote><p>\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52<br>\x53\x89\xe1\x31\xc0\xb0\x0b\xcd</p></blockquote><p>这就是我们的shellcode了</p><h2 id="return-to-address"><a href="#return-to-address" class="headerlink" title="return-to-address"></a>return-to-address</h2><p>有了以上的这些知识我们就可以使用最为简单的ret2addr攻击了。<br>技术的核心是使用覆盖EIP来返回到确认地址，虽然十分简单粗暴，但是随着32位与64位的普及与alsr技术的普及逐渐失去功效，但是在某些特殊的场合这种技术仍然闪烁着光辉。千里之途，始于足下，下面让我们来学习这门技术吧。</p><p>首先我们先温习一遍内存中的数据存放</p><blockquote><p>低  临时变量3 EBP-xxx<br>↓↓  临时变量2 EBP-xxx<br>↓↓  临时变量1 EBP-xxx<br>↓↓  &lt;——EBP<br>↓↓  EBP原值<br>↓↓  EIP原值<br>↓↓  参数1<br>↓↓  参数2<br>高  参数3</p></blockquote><blockquote><p>内存的操作数据的存放顺序是反过来的哦</p></blockquote><p>这一种存储方式虽然高效但是会有一个致命的弱点，那就是内存中临时变量被溢出会把EIP盖掉，导致程序流就会走向你想要的任何地方（前提是没开canary等等的保护，绕过它们的方法以后会写）。</p><p>所以你需要知道shellcode在哪儿，才能精确的跳转至shellcode。这也就是为什么这种技术被称为热ret2addr。一般来说我们会在盖掉EIP的时候顺便在下面写下shellcode所以这个地址我们一般也是知道的。</p><p>在进行这种溢出的过程中我们一般需要确认EIP的地址才可以进行精准的覆盖，不至于让我们的程序滑到谁也不知道的地方去。</p><h3 id="EIP的定位"><a href="#EIP的定位" class="headerlink" title="EIP的定位"></a>EIP的定位</h3><p>有两种方法：<br>1.不停地向新开的程序里丢大小不同的垃圾最后当程序因为异常退出时就可以知道EIP的地址了。<br>2.通过ida看当前栈帧里的内容决定丢多少垃圾进去。<br>有些情况下会发生栈帧很大导致难以试出EIP或者ida分析不出的情况，可以考虑我的另一篇博客的所写的gdb-peda中的pattern大法。</p><h3 id="exp的写法"><a href="#exp的写法" class="headerlink" title="exp的写法"></a>exp的写法</h3><p>通用模板</p><pre><code># -*- coding:utf-8 -*-from pwn import *sh = remote(&quot;????&quot;,????) # 与服务器交互junk = &apos;a&apos;*0x?? # 填充fakebp = &apos;a&apos;*8# 淹没bpsyscall = ?????????????payload = junk + fakebp + p64(syscall) # p64对整数进行打包sh.send(payload)sh.interactive() # 直接反弹shell进行交互</code></pre><blockquote><p>更改？？？？？的内容就可以了。</p></blockquote><h2 id="return-to-register-绕过aslr"><a href="#return-to-register-绕过aslr" class="headerlink" title="return-to-register(绕过aslr)"></a>return-to-register(绕过aslr)</h2><p>虽然说我们上文的技术十分有效，但是魔高一尺，道高一丈，安全技术人员发明了aslr技术对程序进行保护使得偏移量甚至达到2g，这让我们难以确认shellcode的真正位置。</p><blockquote><p>aslr在linux系统上是一个编译选项而非像windows一样是一个链接选项。linux的alsr安全性高于windwos，但是会拖累程序的运行速度，所以aslr在linux上并非很普遍。</p></blockquote><blockquote><p>因为alsr会把栈的基址与栈帧随机掉，那么我们就不知道我们的shellcode会随机到哪里去了。而且确认EIP位置也成了一大难题，因为栈帧的变动会导致EIP变动。</p></blockquote><p>但是真正的黑客从不畏惧艰难，勇于向不可能发起挑战，他们发明了ret2reg技术（当然nop-slide之类的技术也可以做到）</p><blockquote><p>当然aslr+pie依然可以干掉这些大胆的黑客，当然这就是后话了。<br>IDE的优化也可以，（笑</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>系统中的某一些函数会将当前栈帧的地址暴露出来，尤其是处理字符串等。有些情况下会把地址暴露到寄存器中。那么我们在写入shellcode后可以通过寄存器定位，然后在EIP中跳到寄存器位置加上相对偏移。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>如果你一步步按这个方法进行操作的话，你会碰到一个问题。你需要进行</p><pre><code>call xxx//jump xxx</code></pre><p>但是它们在哪呢，我应该怎么样在程序中EIP中填写地址才能跳到那儿呢。aslr有一个特点可以帮助我们解决这个问题，那就是</p><blockquote><p>前文提到使用 echo 2 &gt; /proc/sys/kernel/randomize_va_space 命令将地址混淆技术启用，但该技术对栈空间，堆地址和动态库加载空间都进行了混淆，唯独没有对程序做地址混淆。<br>事实上Linux gcc编译器提供了-fPIE选项，但用它来编译，可使程序空间做地址混淆，造成整个进程地址混淆。但一般的开源软件和商用Linux发行商的服务进程并没有使用-fPIE进行安全增加，还是留下了可利用空间。注意到， stack2在编译时没有使用-fPIE选项。</p></blockquote><p>我们可以通过objdump和grep命令来寻找call xxx相关的指令，然后在EIP中覆写这个地址，然后想办法把shellcode放到寄存器所在的地址去。然后就成功了。</p><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>如果程序中的寄存器指的地方你覆写不了（比如说在溢出点上面），或者下面的程序修改了这个寄存器的值，那这个方法就无能为力了。</p><h2 id="return-to-libc-绕过NX"><a href="#return-to-libc-绕过NX" class="headerlink" title="return to libc(绕过NX)"></a>return to libc(绕过NX)</h2><h3 id="数据执行保护"><a href="#数据执行保护" class="headerlink" title="数据执行保护"></a>数据执行保护</h3><p>在linux环境下所说的NX与windows平台下的DEP是同一个东西，即数据执行保护。</p><p>其功能为通过将非代码段的代码设为不可执行，从而避免程序流被劫持到堆栈等位置的shellcode中。一旦EIP移动到非代码段中，CPU就会报异常，然后杀死这个进程。</p><p>在64位系统上，这个防护的实现主要通过内存页上的NX位。在windows环境下的32位系统则通过软件模拟的方式实现了这一防护。而linux的32位操作系统则没有这样的防护可以选择.</p><blockquote><p>微软在windows XP系统上首先实现了这一防护。<br>此外这一机制在windows上一般被称为DEP，而在linux上被称作NX。</p></blockquote><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>虽然非代码段代码无法正常执行，但是我们可以把代码注入到现成的代码段。我们可以通过调用libc中的system函数来实现我们之前的shellcode中的功能。根据32位函数调用的规范，它会将堆栈中的数据当成参数。而堆栈的更改可以通过溢出等方式来实现（如果开了金丝雀防护的话需要从长计议）。</p><blockquote><p>在linux中使用了libc的加强版本glibc。</p></blockquote><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>因为我们需要伪造一个调用</p><p>所以我们的payload是A*n + system地址（对应EIP） + 返回地址 + “/bash/sh”(参数)</p><p>首先通过pattern生成一个足够大的字符串，定位EIP的位置与A的数量，这都是老生常谈的了。但是我们这次需要查看转储的核心文件core。</p><p>我们通过<code>p system</code></p><p>暴露出libc中system函数的位置。</p><p>当然，如果你想要避免程序的非正常退出（瞎填的EIP使程序走向了奇怪的位置），你也可以在返回地址中填入exit的地址。</p><p>方法为<code>p exit</code></p><blockquote><p>巧妙地设计甚至可以绕过aslr因为不再需要定位shellcode。</p></blockquote><h3 id="局限-1"><a href="#局限-1" class="headerlink" title="局限"></a>局限</h3><p>如果你使用过这个方法的话，你就会发现这个方法是行不通的，因为现在有了一种新的保护机制叫做ASCII armoring来对抗ret2libc，它把libc中所有的地址的第一个字节都设为零，这就导致了在溢出时溢出内容会被截断，而开了NX以后又无法使用shellcode来绕过这一个限制。</p><hr><p>本来应该在之后根据ASCII armoring的弱点讲ret2plt，但是在这之前还需要补充很多知识，才可以继续。故将新开一篇文章来对glibc中的一些特性进行讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个关于栈溢出的指南&lt;/p&gt;
    
    </summary>
    
      <category term="从零开始的ctf之路" scheme="http://yoursite.com/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
