{"meta":{"title":"mian's blog","subtitle":"这里是mian的博客","description":"这是mian的博客","author":"mian","url":"https://www.intmian.com"},"pages":[{"title":"我的朋友们","date":"2019-01-24T10:31:00.609Z","updated":"2019-01-24T10:31:00.609Z","comments":true,"path":"friends/index.html","permalink":"https://www.intmian.com/friends/index.html","excerpt":"","text":"欢迎大佬们互加友链，邮箱联系-_-"},{"title":"关于mian","date":"2018-10-02T02:45:45.400Z","updated":"2018-10-02T02:45:45.400Z","comments":true,"path":"about/index.html","permalink":"https://www.intmian.com/about/index.html","excerpt":"","text":"个人介绍一名普普通通的死宅大学生，ctf、开发、算法业余爱好者。 一只普通的菜鸡。 就读于杭州电子科技大学，现为 HDU-ISA vidar-team 专业开门与烧水成员 想要成为王的男人大神。 前排广告位招租 QA mian和intmian啥关系？是同一个人，正式昵称mian，因为常被占用，会有备用名intmian、mian2333等等。 备注认识我的朋友请在各大社交平台上联系我，不认识的麻烦发邮件。"},{"title":"计划表","date":"2018-10-02T02:44:07.283Z","updated":"2018-10-02T02:44:07.283Z","comments":true,"path":"plan/index.html","permalink":"https://www.intmian.com/plan/index.html","excerpt":"","text":"暑假计划仔细想想暑假里好像啥都干了，好像又啥都没干… 9-10月总结事情太多了，耽搁了学习。不仅仅是ctf、开发。 10-11月 认真学习 吃饭睡觉规律些 系统开始加强bin 开发"},{"title":"友链","date":"2018-06-14T04:46:38.611Z","updated":"2018-06-14T04:46:38.611Z","comments":true,"path":"links/index.html","permalink":"https://www.intmian.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-14T01:00:50.529Z","updated":"2018-06-14T01:00:50.529Z","comments":true,"path":"tags/index.html","permalink":"https://www.intmian.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode contest 151 writeup","slug":"leetcode 121周赛 writeup","date":"2019-08-25T16:00:00.000Z","updated":"2019-08-26T09:09:12.577Z","comments":true,"path":"2019/08/26/leetcode 121周赛 writeup/","link":"","permalink":"https://www.intmian.com/2019/08/26/leetcode 121周赛 writeup/","excerpt":"概要 leetcode第151周周赛 题目 难度 知识点 查询无效交易 简单 无 比较字符串最小字母出现频次 简单 无 从链表中删去总和值为零的连续节点 中等 链表 餐盘栈 困难 设计/无","text":"概要 leetcode第151周周赛 题目 难度 知识点 查询无效交易 简单 无 比较字符串最小字母出现频次 简单 无 从链表中删去总和值为零的连续节点 中等 链表 餐盘栈 困难 设计/无 注:思路是理想思路,代码有可能是我比赛时写的,就不那么理想. 所以代码与思路不一定等价 第一题思路将数据处理后，双重map，然后去重。当然直接做也可以，我在比赛时就是直接做的。 代码12345678910111213141516class Solution: def invalidTransactions(self, transactions: List[str]) -&gt; List[str]: transactions_after: [str, int, int, str] = [] results: List[str] = [] for t in transactions: name, time, num, local = str.split(t, \",\") num = int(num) time = int(time) if num &gt; 1000: results.append(t) transactions_after.append((name, time, num, local)) for (n1, t1, num1, l1) in transactions_after: for (n2, t2, num2, l2) in transactions_after: if n1 == n2 and abs(t2 - t1) &lt;= 60 and l1 != l2: results.append(n1 + \",\" + str(t1) + \",\" + str(num1) + \",\" + l1) return list(set(results)) 第二题思路 将字符串根据f处理成数据 对word排序（代码中，我没有 依次迭代处理（对于排序过得数据可以用二分法确认有几个比较大，由于py中的stl很弱，所以代码中我没有 代码1234567891011121314151617181920212223242526272829303132class Solution: def f(self, s: str) -&gt; int: if s == \"\": return 0 i = 1 min_c = s[0] min_n = 1 while i != len(s): c = s[i] if c &lt; min_c: min_c = c min_n = 1 elif c == min_c: min_n += 1 i += 1 return min_n def numSmallerByFrequency(self, queries: List[str], words: List[str]) -&gt; List[int]: queries_n: List[int] = [] words_n: List[int] = [] for n in queries: queries_n.append(self.f(n)) for n in words: words_n.append(self.f(n)) result = [] for i, n in enumerate(queries_n): low = 0 for n2 in words_n: if n &lt; n2: low += 1 result.append(low) return result 第三题思路 求出前缀和。例 12 3 -3 1 求出 0 1 3 6 3 4。 可以发现前缀和序列中相等的值对，其序号对应的范围在原序列中的子序列恰好值为零。 不停迭代删除子序列，直到有不存在这样的值对 动归也可 代码12345678910111213141516171819202122class Solution &#123;public: ListNode* removeZeroSumSublists(ListNode* head) &#123; unordered_map&lt;int, ListNode*&gt; prefixSum; // 因为头结点也有可能会被消掉，所以这里加一个虚拟节点作为头结点 ListNode* dummy = new ListNode(0), *p = dummy; dummy-&gt;next = head; prefixSum[0] = p; int cur = 0; while (p = p-&gt;next) &#123; cur += p-&gt;val; if (prefixSum.find(cur) != prefixSum.end()) &#123; prefixSum[cur]-&gt;next = p-&gt;next; &#125; else &#123; prefixSum[cur] = p; &#125; &#125; return dummy-&gt;next; &#125;&#125;; 第四题思路 使用栈数组 保存最后一个可以插入的位置一提高push速度 代码123456789101112131415161718192021222324252627282930313233343536373839from typing import Listclass DinnerPlates: def __init__(self, capacity: int): self.stacks: &#123;int: List[int]&#125; = dict() self.size = 0 self.capacity = capacity self.last_not_full = 0 def push(self, val: int) -&gt; None: if self.last_not_full not in self.stacks: self.stacks[self.last_not_full] = [val] self.size += 1 else: self.stacks[self.last_not_full].append(val) i = self.last_not_full while i &lt; self.size and len(self.stacks[i]) == self.capacity: i += 1 self.last_not_full = i def pop(self) -&gt; int: if self.size == 0: return -1 last = self.stacks[self.size - 1] r = last.pop() if len(last) == self.capacity - 1: self.last_not_full = self.size - 1 if len(last) == 0: self.size -= 1 return r def popAtStack(self, index: int) -&gt; int: if index &gt;= self.size or len(self.stacks[index]) == 0: return -1 self.last_not_full = index return self.stacks[index].pop() 后记这次的题目翻译差一点，竞赛的时候看错了好几次。设计题对于性能的限制比预想的低，不需要hack技巧就可以通过，所以其实比第三题简单。第三题想通了其实也挺简单的。还需努力 垃圾hexo，加载latex公式时出错了。。。。。","categories":[{"name":"从零开始的编程之路","slug":"从零开始的编程之路","permalink":"https://www.intmian.com/categories/从零开始的编程之路/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.intmian.com/tags/算法/"},{"name":"编程","slug":"编程","permalink":"https://www.intmian.com/tags/编程/"}]},{"title":"我踩过的c++的坑 续","slug":"我踩过的c++的坑 2","date":"2019-06-06T08:28:15.000Z","updated":"2019-06-08T03:09:50.091Z","comments":true,"path":"2019/06/06/我踩过的c++的坑 2/","link":"","permalink":"https://www.intmian.com/2019/06/06/我踩过的c++的坑 2/","excerpt":"之前我写过一篇长期更新的《我踩过的c++的坑》，因为时间很长，文章太长了，查看起来太麻烦了，所以以后遇到的坑都记在这篇续里 旧文链接 持续更新","text":"之前我写过一篇长期更新的《我踩过的c++的坑》，因为时间很长，文章太长了，查看起来太麻烦了，所以以后遇到的坑都记在这篇续里 旧文链接 持续更新 关于返回右值引用或使用移动语义可能会导致的问题今天写了一个这样的函数 123456T&amp;&amp; f()&#123; T t; //... return move(t);&#125; 这样的代码显然是错误的，因为右值引用实际上也是一种引用，而返回一个临时变量的引用是会出问题的。可以通过编译但是退出f时会报错（在vs2019上，理论上也有可能返回不正确的临时堆栈内容）。 以下的代码才是正确的演示，只要不反回临时变量的都行。 12345template&lt;class S&gt;S&amp;&amp; forward(typename remove_reference&lt;S&gt;::type&amp; a) noexcept&#123; return static_cast&lt;S&amp;&amp;&gt;(a);&#125; 可以看出来我的目的是为了避免一次拷贝。 但是这样的代码也是错的。 123456T f()&#123; T t; //... return move(t);&#125; 因为 实际上这种是不需要的。因为编译器会做返回值优化（Return Value Optimization）。在C++11标准中有如下规定： When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is ﬁrst performed as if the object were designated by an rvalue. 直接return x;是NRVO支持的一种用例场景，可以做到多余的拷贝构造。编译器会自己选择使用拷贝构造还是move构造函数。 但是如果用std::move(x);那么可能会带来额外的影响：可能会阻止NRVO。也就是说可能需要额外的开销来执行move语义。 学艺不精，哎。一直没有研究过右值作为返回值，今天出问题了。以后学东西还是要实践同行。 函数形参中的左值引用不能置入匿名变量（不会自动折叠）例 12void fun(T&amp; t);func(T()); T()不会自动折叠T&amp; 只能这样写 123auto t = T()void fun(T&amp; t);func(t); 头文件中不能出现定义只能出现声明哦，不然一定会出现链接问题。 像是全局变量应该在头文件中 1extern T t; .cpp中 1T t = t0; 匿名对象就是右值，不能传入左值引用中像是T(arg...)这样的匿名对象本质上和1 1.0这样的数值常量差不多。如果你的函数参数是 const T&amp; 或 T&amp;，的话是不能正常调用的。事实上不能通过编译。因为在调用函数后匿名对象就析构了，然后函数里传进去的引用就没有意义了。 正确的函数格式 123void func(T t);void func(T&amp;&amp; t);","categories":[{"name":"从零开始的编程之路","slug":"从零开始的编程之路","permalink":"https://www.intmian.com/categories/从零开始的编程之路/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://www.intmian.com/tags/编程/"},{"name":"c++","slug":"c","permalink":"https://www.intmian.com/tags/c/"}]},{"title":"C++ 中的多返回值的实现","slug":"c++多返回值","date":"2019-05-25T08:28:15.000Z","updated":"2019-05-25T13:53:16.884Z","comments":true,"path":"2019/05/25/c++多返回值/","link":"","permalink":"https://www.intmian.com/2019/05/25/c++多返回值/","excerpt":"本文将循序渐进的从最古老的C风格开始，一直讲到C++17中多返回值的实现方法","text":"本文将循序渐进的从最古老的C风格开始，一直讲到C++17中多返回值的实现方法 C风格传入指针以指针形式传入待返回的值得地址，作为实参，并在类内对其赋值。 经典实现如下 123456void func(int a, int b, int *c, int *d)&#123; // ... do sth with a,b // 对*c,*d赋值&#125; 可以看出我们需要以func(a, b, &amp;c, &amp;d)这样的方式调用func，不仅不方便不直观，而且需要提前定义c, d，代码比较不简洁。而且输入输出不分离，也不大优雅。 返回结构体经典实现如下 123456789typedef struct&#123; int c; int d;&#125; return_v;retuen_v void func()&#123; // do sth return return_v&#123;c, d&#125;;&#125; 麻烦就不说了，还污染了命名空间。而且再调用时，还要准备一个变量接受返回值，再从这个仅用一次的变量中取出需要的变量，太麻烦了。 modern c++ 风格现代c++的多返回值得实现基本上用tuple实现，优雅而简洁。当然和python、go这种语言级的语法糖来说显得还是稍微麻烦一点的。不过有的人相较于语法糖形式的，说不定更喜欢这种学院派的泛型风格也说不定2333。 为什么不用pair pair可以完全被tuple取代。 tuple泛用性更好。 tuple在之后的c++标准中，有着更为重要的地位。也就是说会有越来越多的语法支持。 c++11 风格1234567891011121314151617#include &lt;tuple&gt;std::tuple&lt;int, int&gt; divide(int dividend, int divisor) &#123; return std::make_tuple(dividend / divisor, dividend % divisor);&#125;#include &lt;iostream&gt;int main() &#123; using namespace std; int quotient, remainder; tie(quotient, remainder) = divide(14, 3); cout &lt;&lt; quotient &lt;&lt; ',' &lt;&lt; remainder &lt;&lt; endl;&#125; 用tie来绑定返回值从tuple。虽然比较方便，但是make_tuple这种形式还是稍显扭曲。 自从粗读了c++ stl的代码后，我越发觉得stl的作者太厉害了。就像是上文的这种多返回值语法，实现是非常精妙的。在不添加新的语法糖的情况下，在已有的语法框架下，实现了这么复杂的功能。这非常符合我少即是多的想法，而且统一性好多了2333。 c++17风格 warning 您的编译器未必支持这么新的语法 123456789101112131415#include &lt;tuple&gt;std::tuple&lt;int, int&gt; divide(int dividend, int divisor) &#123; return &#123;dividend / divisor, dividend % divisor&#125;;&#125;#include &lt;iostream&gt;int main() &#123; using namespace std; auto [quotient, remainder] = divide(14, 3); cout &lt;&lt; quotient &lt;&lt; ',' &lt;&lt; remainder &lt;&lt; endl;&#125; 用了新的c++特性，绑定结构体，精妙而美丽。 c++11/c++17混用当然我们也没必要全部使用c++11的特性，或者全用c++17的特性。 他们不互相矛盾，可以这样混用 123456789101112131415#include &lt;tuple&gt;std::tuple&lt;int, int&gt; divide(int dividend, int divisor) &#123; return &#123;dividend / divisor, dividend % divisor&#125;;&#125;#include &lt;iostream&gt;int main() &#123; using namespace std; tie(quotient, remainder) = divide(14, 3); cout &lt;&lt; quotient &lt;&lt; ',' &lt;&lt; remainder &lt;&lt; endl;&#125; 缺点tuple技术没有显示地给出返回值的意义，仅有类型。也就是说你得在注释里给出。 1std::tuple&lt;int, int&gt; divide(int dividend, int divisor); // return &#123;quotient, remainder&#125; warning 如果你的项目中这一点非常重要还是使用结构体法吧。不过话说真的有人有这个需求吗。。。","categories":[{"name":"从零开始的编程之路","slug":"从零开始的编程之路","permalink":"https://www.intmian.com/categories/从零开始的编程之路/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://www.intmian.com/tags/编程/"},{"name":"c++","slug":"c","permalink":"https://www.intmian.com/tags/c/"}]},{"title":"Effective STL 读后感","slug":"《effective STL》读后感","date":"2019-02-20T16:00:00.000Z","updated":"2019-02-21T07:59:51.191Z","comments":true,"path":"2019/02/21/《effective STL》读后感/","link":"","permalink":"https://www.intmian.com/2019/02/21/《effective STL》读后感/","excerpt":"Effective STL 这本书我是在年前从图书馆借的，最近回学校有时间就拜读了一遍。虽然有些地方（函数子，分配子，函数配连，分析机制等等 这么一看，感觉好多啊 ）还没有完全吃透，但是基本上也看的7788了。","text":"Effective STL 这本书我是在年前从图书馆借的，最近回学校有时间就拜读了一遍。虽然有些地方（函数子，分配子，函数配连，分析机制等等 这么一看，感觉好多啊 ）还没有完全吃透，但是基本上也看的7788了。 评测本人的c++水平实在有限，只能从我的一点点经验里稍微说一点。 缺点 成书时间过早，后面作者也没有很大的修改，导致了作者所说的STL和我们现在使用的STL有所区别，诸如unordered_map、unordered_set，这样好用的东西，作者没有着重笔墨，只是作为非标准库提了一嘴。 同样的因为成书相对较早，对于革命性的c++11标准里的新东西，笔者是基本上没有提到的，智能指针什么的也只是作为boost库里的版本提了一口。像not1、bind2nd，这样的东西在生产实践中事实上用的越来越少了，而lambada作为替代品则用的越来越多。虽然在STL，因为为了需求以及bind等历史因素，可能确定严格弱序，或者有序的一般都是三元以下的谓词，对于书中所采用的函数适配器bind2nd、not1，都是适用的。但是 lambda不需要考虑可配连的问题，也就是在在用函数时不用使用fun_ptr，将函数指针特化为可配连的，用函数子对象时，不用考虑继承那些奇奇怪怪的函数子类，省了很多力气。（当然虚函数的剥离，拷贝构造的代价，还是需要考虑的，如果你解决这些问题的方法是bridge pattern的话，内存管理也是要注意的，当然喽，智能指针解千愁） 功能比起自带的适配器强多了。 手写自定义函数适配器是高级技巧，而手写lambda不是。 有些人可能觉得作者废话太多。 翻译有些生硬。例如。 你会受伤，如果不那么做的话。 优点 作为c++ 6E(《Effective C++》《More Effective C++》《Effective Modern C++》《Effective STL》《Exceptional C++》《More Exceptional C++》)系列的一员，Effective 系列的三儿子，成书质量非常的高，对于提高c++水平很有帮助。作者的c++水平很高，因此对于c++问题的理解非常透彻，看了本书可以大大提升作为c++程序员的STL水平。 本书作者对于很难理解的内容，不会堆砌大量的术语，不让人生厌。 此书对于效率的笔墨花了很多，观看本书对于程序速度的提升很有帮助。 有些章节教会了我们如何写出让别人看得懂得代码，对于读者的团队协作和软件工程都有所帮助。 此书对于STL的原理与构造都有所提及，不仅仅让人明白这样怎么做，还让人明白背后的机制。 此书作为一本技术书，却写的十分幽默，不让人感觉无聊。 总体来说这本书极其值得看值得买 后记以前听别人说c++太过于复杂，需要彻底的革新。当初我还是嗤之以鼻，认为c++的复杂都是需要的。但是在我的c++水平也有所上升之后，我才渐渐明白了他们。c++的高级技巧里充满了为了和过去不好的设计或者过于复杂的设计，交互而搞出的过于复杂的设计。不仅仅是我们为了使用c++而搞出来的高级技巧，甚至连标准也是这样，标准越出约厚。甚至这种历史的约束都影响了STL的命名空间，标准里先出现的东西占据了后出现的东西的位置，后出现的本该和它平行的东西却只能屈居人后，使得命名空间中的命名很不系统化、体系化（mem_fun、mem_fun_pre）。产生了很多为了复杂而复杂，和不明所以的东西。有人说c++标准需要的不是小修小补，而是壮士断腕。我是赞同的。历史上的很多过时的设计，没必要再去兼容它们了。 这么说未免过于悲观，最起码c++11以来的c++发展还是给这门老语言灌注了不少新的活力。","categories":[{"name":"从零开始的编程之路","slug":"从零开始的编程之路","permalink":"https://www.intmian.com/categories/从零开始的编程之路/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://www.intmian.com/tags/编程/"},{"name":"c++","slug":"c","permalink":"https://www.intmian.com/tags/c/"}]},{"title":"leetcode contest 121 writeup","slug":"leetcode 第 151 场周赛 writeup","date":"2019-01-28T03:17:05.000Z","updated":"2019-01-30T12:29:51.777Z","comments":true,"path":"2019/01/28/leetcode 第 151 场周赛 writeup/","link":"","permalink":"https://www.intmian.com/2019/01/28/leetcode 第 151 场周赛 writeup/","excerpt":"概要第121周的leetcode周赛共有4题 leetcode第121周周赛 题目 难度 知识点 不含AAA或BBB的字符串 简单 没有/贪心 基于时间的键值存储 中等 数据结构 最低票价 中等 动态规划 按位与为零的三元组 困难 数学","text":"概要第121周的leetcode周赛共有4题 leetcode第121周周赛 题目 难度 知识点 不含AAA或BBB的字符串 简单 没有/贪心 基于时间的键值存储 中等 数据结构 最低票价 中等 动态规划 按位与为零的三元组 困难 数学 不含AAA或BBB的字符串题目 题目 思路有两种思路 普通思路 因为必然存在解 所以用数量少的字母隔开多的字母，使多的一方尽量均匀分配。 例如：A = m B = n (m &gt; n) ((m / (n + 1)) A B)n (m / (n + 1)) * A 因为整数除法可能出现小数，就将小数聚拢 例如 A = 5 B = 3 5 / 4 = 1.25 所以把 5 分成 1 个 2 、三个 1 贪心算法 高射炮打蚊子了解一下 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: string strWithout3a3b(int A, int B) &#123; if (A == B) &#123; string result; while (A--) &#123; result.append(\"ab\"); &#125; return result; &#125; int max, min; char max_c = 'a'; char min_c = 'b'; string result; if (A &gt; B) &#123; max = A; min = B; &#125; else &#123; max = B; min = A; max_c = 'b'; min_c = 'a'; &#125; int num_divide_part = min + 1; int num_1 = num_divide_part * 2 - max; int num_2 = num_divide_part - num_1; while (num_1--) &#123; result.push_back(max_c); result.push_back(min_c); &#125; if (num_2 == 0) result.pop_back(); else &#123; while (num_2--) &#123; result.push_back(max_c); result.push_back(max_c); result.push_back(min_c); &#125; result.pop_back(); &#125; return result; &#125;&#125;; 基于时间的键值存储题目 基于时间的键值存储 思路使用map和unordered_map 用map映射key到\\&lt;time,stamp&gt; 用unordered_map映射time到stamp 前面用map的理由是保证常数级的查询时间 后面用unordered_map是为了尽快查出那个最大的time，如果使用map可能需要n级的时间。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class TimeMap &#123;public: /** Initialize your data structure here. */ TimeMap() &#123; &#125; unordered_map&lt;string, map&lt;int, string&gt;&gt; my_map; void set(string key, string value, int timestamp) &#123; if (my_map.find(key) != my_map.end()) &#123; my_map[key][timestamp] = value; &#125; else &#123; my_map[key] = map&lt;int, string&gt;(); my_map[key][timestamp] = value; &#125; &#125; string get(string key, int timestamp) &#123; if (my_map.find(key) == my_map.end()) &#123; return \"\"; &#125; else &#123; auto &amp;find_map = my_map[key]; for (auto it = --find_map.end(); it != find_map.begin(); it--) &#123; if ((*it).first &lt;= timestamp) &#123; return (*it).second; &#125; &#125; if ((*find_map.begin()).first &lt;= timestamp) &#123; return (*find_map.begin()).second; &#125; else &#123; return \"\"; &#125; &#125; &#125;&#125;; 最低票价题目 最低票价 思路因为求得是最优化问题，而且可以分成若干个阶段，因此我们很容易想到dp。因为最低票价显然是个一元谓词，我们就设dp(n)是第n天的最低票价。 先列出状态转移方程 $$\\begin{cases}dp_i = \\min(dp_{i+1}+costs_0,dp_{i+7}+costs_1,dp_{i+2}+costs_{30}) &amp; i\\in days \\dp_i = dp_{i+1}&amp;i \\notin days \\and i &lt; \\max(days) \\dp_i = 0 &amp; i &gt; \\max(days)\\end{cases}$$ 然后注意下记忆优化，避免重复的迭代展开。搞个哈希表就行(unordered_map)。 不优化的话复杂度就变成O(3 ^ n) 代码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: unordered_map&lt;int, int&gt; dp_pre = unordered_map&lt;int, int&gt;(); set&lt;int&gt; days_traval = set&lt;int&gt;(); int max_days; int dp(int day, vector&lt;int&gt;&amp; costs) &#123; int result; if (dp_pre.find(day) != dp_pre.end()) return dp_pre[day]; if (day &gt; max_days) &#123; dp_pre[day] = 0; return 0; &#125; if (days_traval.find(day) == days_traval.end()) &#123; result = dp(day + 1, costs); dp_pre[day] = result; return result; &#125; auto &amp;&amp; dp_datas = &#123;dp(day+1,costs)+costs[0],dp(day + 7,costs) + costs[1],dp(day + 30,costs) + costs[2]&#125;; result =*min_element(dp_datas.begin(), dp_datas.end()); dp_pre[day] = result; return result; &#125; int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123; for (auto day : days) &#123; days_traval.insert(day); &#125; max_days = *max_element(days.begin(),days.end()); return dp(1,costs); &#125;&#125;; 按位与为零的三元组题目按位与为零的三元组 思路这个其实是一个数论题。。。 如果硬要做还挺麻烦的，但是似乎leetcode官方没有设好时间，所以穷举也可以。。。 更好的方法就看官方的吧。 代码123456789101112131415161718class Solution &#123;public: int countTriplets(vector&lt;int&gt; A) &#123; int sum = 0; for (int i = 0; i &lt; A.size(); i++) &#123; for (int j = 0; j &lt; A.size(); j++) &#123; for (int k = 0; k &lt; A.size(); k++) if ((A[i] &amp; A[j] &amp; A[k]) == 0) &#123; sum++; &#125; &#125; &#125; return sum; &#125;&#125;; 后记这次因为第一题看错题了，第三题摸鱼，导致没特别做好，就当长知识了吧-_- 垃圾hexo，加载latex公式时出错了。。。。。","categories":[{"name":"从零开始的编程之路","slug":"从零开始的编程之路","permalink":"https://www.intmian.com/categories/从零开始的编程之路/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.intmian.com/tags/算法/"},{"name":"编程","slug":"编程","permalink":"https://www.intmian.com/tags/编程/"}]},{"title":"如何重装系统","slug":"重装系统","date":"2019-01-27T09:43:11.000Z","updated":"2019-01-27T11:08:30.065Z","comments":true,"path":"2019/01/27/重装系统/","link":"","permalink":"https://www.intmian.com/2019/01/27/重装系统/","excerpt":"前言本来我是不想写这篇文章的因为懒。 但是有鉴于最近找我装系统的人太多了，再加上看见小白被无良商家骗于心不忍，就写篇教程吧-_-。 我会把装机的主要几个阶段讲一下，但是任何跟着提示稍微理解下就可以无风险走的小步骤就不讲了。","text":"前言本来我是不想写这篇文章的因为懒。 但是有鉴于最近找我装系统的人太多了，再加上看见小白被无良商家骗于心不忍，就写篇教程吧-_-。 我会把装机的主要几个阶段讲一下，但是任何跟着提示稍微理解下就可以无风险走的小步骤就不讲了。 装系统之前的准备首先要有个概念 装系统是一件很简单的事。电脑是一件给人用的 工具 ，厂商没有理由设置门槛。装机是很简单的，但是最好不要随意重装系统，文件、软件重新安置太麻烦了。 准备阶段 物理准备 一只8G以上U盘 心理准备 一小时不到的时间 一定的理解能力 装机阶段 找到你所用电脑的主板厂商（不需要拆机箱，直接用aida64或者别的软件看）以及型号，如果是笔记本就直接使用电脑型号。 搜索 xxxx（你的主板型号） 进入bios的快捷键，并记住它。 在msdn 我告诉你，这个网站上找到你要装的系统的 64位 最新版本。 下载它。 格式化U盘。 把下载的镜像文件用解压软件解压到U盘。 备份c盘里的文件，其它盘看你想不想顺便格式化。 重启，并在开机的过程中狂按你记住的快捷键。 你将会进入一个蓝蓝白白的界面（bios），请动用你的英语水平进行翻译后使用。 你有两个选择 UEFI路线 找到boot里面的UEFI设置为ENABLE 重启，开机过程中狂按快捷键 会看见弹出一个对话框，选择 WINDOWS BOOT MANAGER 传统路线 找到boot里面的启动顺序 按照操作指示，把U盘放到最上面 重启 在Windows安装指示界面中，按照指示操作进行操作 分区格式化请谨慎 开机后联网会自动安装驱动 在你的显卡的对应官网下载安装显卡驱动 在设备管理器中查看有无设备上有感叹号标识，若有，去官网下载驱动。 是否安装360、驱动大师等软件自行判断 我推荐ccleaner、火绒 重启进入bios，把设置还原为改动之前的 后记简单的电脑维护其实很简单(废话)，只要不先入为主地认为自己不会，善用搜索引擎，不懂的东西稍微研究一下，一般都没有问题的。 我不对任何本文后果负责，还请读者们自行判断。","categories":[{"name":"一些小教程","slug":"一些小教程","permalink":"https://www.intmian.com/categories/一些小教程/"}],"tags":[{"name":"电脑维护","slug":"电脑维护","permalink":"https://www.intmian.com/tags/电脑维护/"}]},{"title":"sql中的连接","slug":"sql 连接","date":"2019-01-23T06:12:15.000Z","updated":"2019-01-30T11:48:43.770Z","comments":true,"path":"2019/01/23/sql 连接/","link":"","permalink":"https://www.intmian.com/2019/01/23/sql 连接/","excerpt":"一些关于sql语句的连接的小知识","text":"一些关于sql语句的连接的小知识 为什么要用连接查询例子下面我举个例子 有这样两张表 student id name class_id 1 mian 1 2 mki class id name 1 cs 2 如果我们需要查询每个学生选的课，按照传统的方法我们可以 123select student.name,class.namefrom student,classwhere student.class_id = class.id 但是如果熟悉sql原理的同学就会知道这样的 from student,class 这样的语句本质上是求$$student \\times class$$（笛卡尔积） 生成了这样一张表 id name class_id id name 1 mian 1 1 cs 1 mian 1 2 2 mki 1 cs 2 mki 2 再从中选择$$\\sigma _{student.class_id=class.id}$$这样子显然当student和class非常大时，查询效率太低。 连接数学既然笛卡尔迪行不通，我们就想到了我们的老朋友连接（join）$$student\\Join class$$这样子就可以衍生出一张不比代查询的两张表大的表的。 用法此处我们就应该用 join 这种sql语法 join跟据匹配生成元组的方式分为四种 内连接 inner join 左连接 left join 右连接 right join 全连接 full join 内连接定义生成的行数为左表右表全部匹配的行 用法123from sdudentinner join classon student.class_id = class.id 结果 id name class_id id name 1 mian 1 1 cs 左连接定义左表的所有元组加上匹配的右表元组 用法123from sdudentleft join classon student.class_id = class.id 结果 id name class_id id name 1 mian 1 1 cs 2 mki 右连接定义右表的所有元组加上匹配的左表元组 用法123from sdudentright join classon student.class_id = class.id 结果 id name class_id id name 1 mian 1 1 cs 2 全连接定义所有左右表的元组相互匹配 用法123from sdudentfull join classon student.class_id = class.id 结果 id name class_id id name 1 mian 1 1 cs 2 mki 2 后话Typora 真香 Latex 真香","categories":[{"name":"从零开始的编程之路","slug":"从零开始的编程之路","permalink":"https://www.intmian.com/categories/从零开始的编程之路/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://www.intmian.com/tags/编程/"},{"name":"sql","slug":"sql","permalink":"https://www.intmian.com/tags/sql/"}]},{"title":"在vs2017进行泛型模板编程的一些笔记","slug":"泛型","date":"2018-12-01T12:09:00.000Z","updated":"2019-01-24T09:37:59.723Z","comments":true,"path":"2018/12/01/泛型/","link":"","permalink":"https://www.intmian.com/2018/12/01/泛型/","excerpt":"前言我周末用c++，写数据结构的作业，出于装逼炫技（这两个词好像没差）的目的，我用oop的思想，和现代c++的语法来写作业。 其中我很自然的使用了泛型加上一些一些工程技巧。 而很遗憾的的是，当中出现了非常多的一些问题，一些是由于我对于c++的学习还不是很熟练，另一些则是因为编译器对于modern c++支持得不好，或者vs对它支持的不好。","text":"前言我周末用c++，写数据结构的作业，出于装逼炫技（这两个词好像没差）的目的，我用oop的思想，和现代c++的语法来写作业。 其中我很自然的使用了泛型加上一些一些工程技巧。 而很遗憾的的是，当中出现了非常多的一些问题，一些是由于我对于c++的学习还不是很熟练，另一些则是因为编译器对于modern c++支持得不好，或者vs对它支持的不好。 模板类中的模板类中的子类读上去好像有点绕口，我们举个栗子 123456789101112template&lt;class T&gt;class O&#123;private: vector&lt;T&gt; ts;public: O(vector&lt;T&gt; sourse) :ts(sourse) &#123; vector&lt;T&gt;::itereator it = ts.begin(); &#125;&#125;; 看上去没啥问题，可是一旦我们编译，就会 只是为什么呢？ 因为vector&lt;T&gt;::itereator这段语句内，因为vector&lt;T&gt;是不确定的，所以我们的编译器无法确认所谓的iteratoe(注：图中的代码，单词打错了，但是不影响结果，望别介意)是vector&lt;T&gt;的子类还是静态变量 注：子类这个说法是不准确的，详见stl源码 二义性是计算机系统难以接受的，所以报错。 至于为什么IDE不报错，又是另一个故事了 为了消除二义性 12345678910111213template&lt;class T&gt;class O&#123;private: vector&lt;T&gt; ts;public: O(vector&lt;T&gt; sourse) :ts(sourse) &#123; typename vector&lt;T&gt;::iterator; &#125;&#125;; 像我这样加上typename就可以消除二义性，声明后面的iterator是一个类型，而非一个变量。 没有提示，没有报错像是我们上文的代码，如果你的IDE有自动补全的话，你就会发现ts.这样的代码会触发自动补全而vector&lt;T&gt;这样的代码就不行。 这可能有比较深的原因，但是挺坑的，就记一下吧 没有动态报错情况详见代码 对于模板函数或者模板类内部的代码，不会进行动态检验，因此使用vs写的时候，我们的体验就回归了vc++（==）。 至于原因，我咨询了大佬，大佬也不知道，那就凉凉喽 error type的原因出现这种情况有两种可能 参数类型写错了，这是绝大多数的情况，因为vs的类型推导十分zz，再加上没有动态检验，就会出现类型推到错误,也就是说函数的第一个参数写错了，后面的参数以及函数体里的变量都会显示error-type 类的顺序错了，不说了，太zz了 分离编译如果你恰好遇到了编译失败，原因是符号问题，那你可能是吃了分离编译的亏，因为，现在的编译器没有一个支持泛型的分离编译的。因为编译是对单个文件进行的，之后再进行链接。 error LNK2019: 无法解析的外部符号 &quot;void __cdecl func&lt; int&gt;(int const &amp;)&quot; (??$func@H@@YAXABH@Z) 我们来复习一下模板的实现 程序员写出模板（例如模板函数） 程序员在别的地方确立对于模板的调用 编译器将模板的实例化调用符号化为符号 根据符号来生成对应符号化的模板函数 也就是说当编译过程一过，编译器将不会再去实例化函数 参考一位大佬的回答 原因出现在分离编译模式上。在分离编译模式下，func.cpp会生成一个目标文件为func.obj，由于在func.cpp文件中，并没有发生函数模板调用，所以不会将函数模板func&lt; T&gt;实例化为模板函数func&lt; int&gt;，也就是说，在func.obj中无法找到关于模板函数func&lt; int&gt;的实现代码。在源文件main.cpp中，虽然函数模板被调用，但由于没有模板代码，也不能将其实例化。也就是说，在main.obj中也找不到模板函数func&lt; int&gt;的实现代码。这样，在连接的时候就会出现func&lt; int&gt;没有定义的错误。 所以要把函数的定义和声明放在同一个文件 在同一个文件里进行类似调用也行，但是不推荐 和普通函数不同的是，这里不会报函数重定义的错，这是对于模板函数的特殊照顾 泛型的尖括号不补全这问题请找罪魁祸首微软 静态函数成员的一些问题当我们定义一些类的静态方法时，我们会很震惊的发现，vs把静态方法的声明和下面的定义视为两个符号，而定义的函数体内，会失去绝大多数高亮补全，或者报错。而且内部的符号在vs中全部是未定义状态。而编译器最后解析的时候都是一视同仁的。 解决方法可以考虑将定义和声明放在一起，但是并没有解决实际问题23333 至于真正的解决方法，只有等vs更新了。 模板类内双重模板与auto的推导错误假定有 1234567891011121314template &lt;typename T&gt;void ShowProcess(vector&lt;vector&lt;T&gt;&gt; elements, string tip)&#123; cout &lt;&lt; tip &lt;&lt; endl; for (auto line : elements) &#123; for (auto element : line) &#123; cout &lt;&lt; setw(4) &lt;&lt; element; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125; 按照正常情况，这段代码一点问题都没有。 实际上这里会出现推导错误 line会被推导为T类型，然后雪崩 应该改为 1234567891011121314template &lt;typename T&gt;void ShowProcess(vector&lt;vector&lt;T&gt;&gt; elements, string tip)&#123; cout &lt;&lt; tip &lt;&lt; endl; for (vector&lt;T&gt; line : elements) &#123; for (auto element : line) &#123; cout &lt;&lt; setw(4) &lt;&lt; element; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"从零开始的编程之路","slug":"从零开始的编程之路","permalink":"https://www.intmian.com/categories/从零开始的编程之路/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://www.intmian.com/tags/编程/"},{"name":"c++","slug":"c","permalink":"https://www.intmian.com/tags/c/"}]},{"title":"耦合与解耦","slug":"解耦","date":"2018-10-23T05:58:27.000Z","updated":"2019-01-25T07:20:28.442Z","comments":true,"path":"2018/10/23/解耦/","link":"","permalink":"https://www.intmian.com/2018/10/23/解耦/","excerpt":"高内聚，低耦合是你们我一直所追求的目标","text":"高内聚，低耦合是你们我一直所追求的目标 前言本人只是个菜鸡，只是写一些自己对于架构的一些小小的理解，可能会出偏差 何为耦合耦合性（英语：Coupling，dependency。或称耦合力或耦合度）是一种软件工程的度量，是指一程序中，模块及模块之间信息或参数依赖的程度。 内聚性是一个和耦合性相对的概念，一般而言低耦合性代表高内聚性，反之亦然。耦合性和内聚性都是由提出结构化设计概念的赖瑞·康斯坦丁所提出。低耦合性是结构良好程序的特性，低耦合性程序的可读性及可维护性会比较好。 看到了上面的那句话，可能会感觉概念还是有所模糊。我们毕竟是写代码的不是写文章的嘛，也就不需要说那么多没什么用的废话了。 也就是说我们的一个程序中几个不同的基本模块（可能是函数、类或者更小的基本单位）中存在着互相调用或者互相依赖的行为。 耦合的例子例子112345678void change(const vector&lt;int&gt;&amp; source)&#123; GetTool(\"H_1\")-&gt;add(source[1]); if (source[1] &gt; 10) GetTool(\"A_0\")-&gt;change(source[1]); if (source[1] &lt; 10) GetTool(\"A_1\")-&gt;change(source[1]);&#125; 举这一个并不极端的例子，是因为我编不出来了这是我平时碰到的真实的问题。当我写完代码是又回头看了一眼,发现。 我*。 他妈的应该是source[2]…于是我一一把他们从1改为2。也许你们觉得这也没什么大不了的，不就是一一替换嘛，有什么大不了的。但是如果我给你个500行的复合模块，然后你把source[2]写成了source[1]，而且在函数的正确的逻辑中本来就有source[1]。那我们就不能简单的替换，而需要从头审逻辑，再改。甚至可能需要重写，这个代价就太大了。 这就是耦合的一种，过度（自己体会）使用了其他的模块的数据 例子2举个比较zz的例子 123xxx_0 = xxx_0 * 11 + 1;xxx = ToList(xxx_0);GetTool(\"IDX\")-&gt;add(xxx); 这样的代码大家一定经常用到。有些人（我），经常性的将这些段落直接复制粘贴来来去去。最后在改动的时候，就需要全篇的瞎瘠薄乱改，最后浪费了巨量的时间。 例子3比方说我们有菜单类和按钮类。而按钮显然是在菜单里的。 我们现在是把按钮写死在菜单里好呢，还是各自独立好呢。 显然的，自然是同为独立类，再讲按键映射到菜单里好。因为菜单和按钮显然不是固定的关系，一个菜单拥有不定数量的按钮。如果写在一起的话，其实是很僵化的，换言之，耦合度太高，不利于维护和扩展。我们应该在菜单里以引用表的形式将按钮组合进去 例子4想必大家对于java的set、get这个段子，应该有所耳熟，可是为什么这么写呢。 主要是为了解耦。我呢，架构能力很差，就引用大佬的话来说说吧。 很多人，并不是面向对象学得不好，但总觉得差什么，我也经历过，面向对象，封装，多态，继承，学过的人都知道，都认为自己了解了，其实不然，很多很奇妙的因素，让你误解了，大部分的人认为封装很简单，其实大错特错了，封装是最奇妙的，也是最难用好的。只要你记住以下原则，必然能很好地用好封装，成员尽量使用protected和private，不要去使用public.尽量不要提供给外部对成员属性getter的接口，意思就是不要暴露成员，为什么要这样呢？很简单，暴露成员属性必然会导致自身业务的外泄，业务外泄，会导致，类之间的无谓耦合，如A类有成员a,而程序需要对a数据改变，而你提供一个B类可以访问a成员的getter接口，B类在其自身对a修改，看上去没什么，实际上，就是类耦合，对a的修改是类A的职务，由于习惯的提供getter，导致了，在写类B的时候错误地添加了修改业务，使类A内聚能力降低，程序逐步庞大必然会越发明显，真所谓牵一发动全身，小程序确实是很难看出问题所在。 如何避免耦合 我呢水平一般，只能提出一点点微小的建议 大的函数如果有可能只用到小的功能时，一定要把它分割。 如果重复的一部分反复用到的话，需要注意把它单独拿出来。 注意封装与设计模式。 具体实现方法part 1先看一段代码 123456789101112void Set(MODE mode)&#123; switch (mode) &#123; case A: ... case B: ... default: assert(false); &#125;&#125; 这是一个实际程序中的设置方法，其中MODE是一个枚举类。根据解耦的思想应该改为。 void SetA(…) … void SetB(…) … … void Set(MODE mode) { switch (mode) { case A: SetA(…); case B: SetB(…); default: assert(false); } } part 2123456config_add = Nonedef SetConfigAdd(): global config_add config_add = xxxdef PushSetToFile(): # use config_add to do sth 像是这样的代码就不大好，全局的设置变量是一种相当不安全、不专业的行为(但是我很喜欢啊)。 应该在需要出现config_add的最大作用域(不超过主函数)，声明config_add，把它作为引用或者常引用映射进去。(特指某些语言) 后记架构设计对于程序员要求非常高。我只学了一些皮毛，甚至有些方法都只是我自己想的。所以只做参考吧。 学习！学习！","categories":[{"name":"从零开始的编程之路","slug":"从零开始的编程之路","permalink":"https://www.intmian.com/categories/从零开始的编程之路/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://www.intmian.com/tags/编程/"},{"name":"架构","slug":"架构","permalink":"https://www.intmian.com/tags/架构/"}]},{"title":"关于谷歌c++编程规范","slug":"关于谷歌c-编程规范的一些理解","date":"2018-08-11T03:17:05.000Z","updated":"2019-01-24T12:17:23.125Z","comments":true,"path":"2018/08/11/关于谷歌c-编程规范的一些理解/","link":"","permalink":"https://www.intmian.com/2018/08/11/关于谷歌c-编程规范的一些理解/","excerpt":"良好的命名真的很重要","text":"良好的命名真的很重要 谷歌命名规范一个图片大纲 附上我看见过的最全面的博客 谷歌c++规范 为啥不用匈牙利命名法早期坚定拥护匈牙利命名法的Microsoft在 .NET Framework后，已经不再建议程序员使用匈牙利命名法了。 微软新的变量名称建议General Naming Conventions原文如下： Donot use Hungarian notation. Hungarian notation isthe practice of including a prefix in identifiers to encode some metadata aboutthe parameter, such as the data type of the identifier. 附上一句很经典的原话： “避免使用匈牙利记法，它会让你的承诺落空。赘物并非信息，而是混淆耳目的伪信息。” 谷歌规范检查工具Cpplint是一个python脚本，Google使用它作为自己的C++代码规范检查工具。如果你所在的公司也使用Google C++代码规范，那么你有必要了解下Cpplint。 下面说一下Cpplint在windows下的简单使用： 从此处下载cpplint.py源码，并将其存放到D:\\soft\\Cpplint\\cpplint.py中； 安装python2，并将D:\\ProgramFiles\\Python27 添加到系统环境变量Path中； vs用户可以参考这个博文来进行配置。","categories":[{"name":"从零开始的编程之路","slug":"从零开始的编程之路","permalink":"https://www.intmian.com/categories/从零开始的编程之路/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://www.intmian.com/tags/编程/"},{"name":"c++","slug":"c","permalink":"https://www.intmian.com/tags/c/"}]},{"title":"hexo原生无插件快速引入图片","slug":"hexo原生无插件快速引入图片","date":"2018-07-28T09:43:11.000Z","updated":"2019-01-25T07:26:25.149Z","comments":true,"path":"2018/07/28/hexo原生无插件快速引入图片/","link":"","permalink":"https://www.intmian.com/2018/07/28/hexo原生无插件快速引入图片/","excerpt":"前情提要说出来你可能不信，笔者常年不知道如何在hexo里面上传图片，导致有些图片都是网上找的，不仅不稳定，时不时还会因为盗链被加入黑名单。现在说起来可真是一段血泪史啊。于是笔者看今天天气不错（大雾），决定搞一波图片。","text":"前情提要说出来你可能不信，笔者常年不知道如何在hexo里面上传图片，导致有些图片都是网上找的，不仅不稳定，时不时还会因为盗链被加入黑名单。现在说起来可真是一段血泪史啊。于是笔者看今天天气不错（大雾），决定搞一波图片。 话说现在的vs-code的markdown插件可真是奇怪他竟然把我的源代码给渲染了… ## 方法### 传统方法在markdown中常用的链接图片的方式是1![图片描述](图片地址)我们要不把图片传到图床，要不盗链。### hexo方法#### 文件放在哪但是我们今天用的是hexo，可以把本地的一些文件传到hexo博客在你的托管文件夹里面。我们有两种方法 传到source文件夹中然后用相对路径访问它。 传到与你的markdown同名的文件夹里，然后用相对路径访问它。毫无疑问，前一种方法存在命名空间混乱而且路径较长的问题，我们选择无视。#### 开启自动创建文件夹在hexo中，我们在没有hexo_gui的情况下，我们会使用hexo new xxx来创建md文件。如果我们把hexo配置文件中的post_asset_folder选项配置为true，就可以在使用new命令时自动生成对应的文件夹。我们把图片放在里面就会一起上传。#### 在hexo使用文件夹里的图片我们依然使用![]()来创建图片链接。此时我们的编辑器会提示补全,以本文为例，会被补全为1![](hexo原生无插件快速引入图片/1.png)我们试着使用本地测试的方式于是我们会发现图片，在编辑器里被加载出来了，在博客中没有被加载出来，于是我们怀疑hexo在上传时改变了文件夹的结构。于是我传到了github上去试了一试，果不其然，发现图片与博客被解析到了同级文件夹中。于是正确的使用方法是1![](1.png)虽然很遗憾的是编辑器的预览里面看不见这玩意。当然使用hexo独有的插入图片的语法也是一样，需要使用相同的技巧。当然在我目前的3.0版本这两种语法的效果是一样的…## 居中显示如果一个图片比较小的话，在markdown里面直接插入是很难看的。但是markdown支持html语法。于是我们可以把![插件错误](1.png)改为123&lt;div align=center&gt;![插件错误](1.png)&lt;/div&gt;效果如下— 当然我现在使用的编辑器并不能预览会把命令解析为文字，但在hexo中亲测可用。 编辑器中，我看见的预览是↓ 那也是没办法的事嘛。md普通话和方言之间确实有所差异。","categories":[{"name":"一些小教程","slug":"一些小教程","permalink":"https://www.intmian.com/categories/一些小教程/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.intmian.com/tags/hexo/"}]},{"title":"我踩过的c++的坑","slug":"我踩过的c++的坑","date":"2018-07-21T08:28:15.000Z","updated":"2019-06-06T06:07:35.963Z","comments":true,"path":"2018/07/21/我踩过的c++的坑/","link":"","permalink":"https://www.intmian.com/2018/07/21/我踩过的c++的坑/","excerpt":"c++坑还挺多的，以后每个坑我都记录下来持续更新","text":"c++坑还挺多的，以后每个坑我都记录下来持续更新 在类的实例化时不能使用其他的类的构造函数例如 123TCHAR current_directiom[100];GetCurrentDirectoryW(200, current_directiom);Installer in(wstring(curren)); 理论上没毛病。 但是在笔者的环境中in被视为一个函数而非一个类。 必须要写成 TCHAR current_directiom[100]; GetCurrentDirectoryW(200, current_directiom); wstring path(current_directiom); Installer in(path); 才行 123char current_directiom[100];GetCurrentDirectoryA(200, current_directiom);string path = string(current_directiom) + string(\"\\\\data\\\\setting.ini\"); 而这样的却又是可以的，迷 两个指针作为参数不能重载运算符1QListWidget * operator&lt;&lt;(QListWidget *output, char *your_output); 这样的语句是错误的,为避免出现内置类型的重载，必须有一个及以上的参数为类或枚举类型 单例模式请务必加锁今天偷懒，写了一个简化版的单例模式，没加异步锁，被别人看出来了。。。 别再using namespace std了这会极大的污染命名空间。很容易产生c226不明确问题 替代方法 using xxx::yyy xxx: 命名空间yyy：标识符 关于switchswitch其实是一个流控制器。如果你用了比较传统的写法 1234...case A :...break 那么你在A中定义的变量会一路传下来，这是不安全的。所以会报错。 解决方案： 123456...case A :&#123; ...&#125;break 让变量超出范围就消失就行了。 如果你下文的逻辑还要用到这个变量，就把它定义到swutch块前面去。 输入输出重定向的问题不要在powershell中进行输入输出重定向，会报很多神奇的错误，改成cmd即可。 别在迭代器中使用erase例如这段代码 12345678for (auto num_ptr = digits.begin(); num_ptr != digits.end(); num_ptr++)&#123; if (*num_ptr == 0) &#123; digits.erase(num_ptr); digits.push_back(0); &#125;｝ 会出现错误 这段错误在STL中的源码我也放下 1234567if (this-&gt;_Getcont() == 0 || this-&gt;_Ptr == 0 || ((_Myvec *)this-&gt;_Getcont())-&gt;_Mylast &lt;= this-&gt;_Ptr)&#123; // report error _DEBUG_ERROR(\"vector iterator not incrementable\"); _SCL_SECURE_OUT_OF_RANGE;&#125; this-&gt;_Getcont()的源码是 1return (_Myproxy == 0 ? 0 : _Myproxy-&gt;_Mycont); 原来的迭代器在erase后已经失效了 解决方案把迭代器自增分出来 123456789101112for (auto num_ptr = digits.begin(); num_ptr != digits.end();)&#123; if (*num_ptr == 0) &#123; num_ptr = digits.erase(num_ptr); digits.push_back(0); &#125; else &#123; num_ptr++; &#125;&#125; stl算法的前后界陷阱笔者在今天写代码的时候碰到了一个问题，max_element总是出错，找出来的不包括最后一个，一番研究后啼笑皆非。 我们使用这个函数对整个容器进行操作时，一定会用max_element(vec.begion(),vec.end())，其中的end()是最后一个迭代器的下一个。但是我们在对容器的一部分进行操作时，却容易忘记掉，第二个参数的意义，最后导致少操作了一个。。。 关于system严格来说，这个不能算是c++的坑，而应该算是c语言和c++一起搞出来的的坑。 system函数，总所周知，是不需要库的（c++），而我又好久没有写过pure c了，于是某日我在用pure c写代码时，突然发现system函数怎么命名空间里没有，而我那时恰好在给学妹演示代码，于是就变成大型翻车现场了…后来我发现，这个函数在c中其实放在stdlib.h里面。 我觉得c++标准库不再需要标明.h是一个重大的创举2333 关于相对路径需要注意的是当你使用相对地址，或者使用某些库求地址的库时，其基准地址会存在陷阱。 对于代码a.txt按照道理你想要达成的是通过相对地址访问与程序同一个层次的a.txt。 对于直接运行程序来说，你得到的就是正确的结果。 对于命令行运行的程序例如.\\xxx\\a.exe时，你的基准地址为命令行的工作目录，这就会导致你访问不到，或者访问了错误的a.exe。 关于类的定义先后在vs中偶遇 error C2143: 语法错误: 缺少“;”(在“&lt;”的前面)note: 参见对正在编译的类 模板 实例化“LList”的引用error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 interror C2238: 意外的标记位于“;”之前error C2143: 语法错误: 缺少“;”(在“&lt;”的前面)error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 interror C2238: 意外的标记位于“;”之前error C2143: 语法错误: 缺少“;”(在“&lt;”的前面)error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 interror C2238: 意外的标记位于“;”之前 这样的一大堆错误。 我当时看了很长时间都没发现错误，而且静态检测中也没报错。就是实例化后会出现类型推倒失败。我开始也以为是类的前后问题。但是因为内含类未报错。所以也就没有接着看了。 再把组合的成员声明放在总成员上后，问题就解决了。 总的来说vs，这方面的问题检验还有点问题。所以以后看到这样的错误要自己注意下LOL。 有关于类多重引用的顺序设有A,B两类 123456789101112131415161718class A&#123;private: int a,b;public: A(B b): a(b.a),b(b.b) &#123;&#125;&#125;class B&#123;private: int a,b;public: B(A a): a(a.a),b(a.b) &#123;&#125;&#125; 这样子的代码是错误的，因为编译器是自顶而下编译的，在编译A类时，不知道B类的情况，甚至不知道B类。 那我们改一下，提前告诉编译器A类的存在 12345678910111213141516171819class B;class A&#123;private: int a,b;public: A(B b): a(b.a),b(b.b) &#123;&#125;&#125;class B&#123;private: int a,b;public: B(A a): a(a.a),b(a.b) &#123;&#125;&#125; 这样子可以了吗？答案是这样子也是不行的，因为在A类中用到了b.a这样的东西，而编译器虽然知道B的存在，但是也就仅仅知道它的存在，换言之，这是个不完整类型。而编译器不能访问不完整类型的成员。 可以改成指针形式 12345678910111213141516171819class B;class A&#123;private: int a,b;public: A(B *b): a(b-&gt;a),b(b-&gt;b) &#123;&#125;&#125;class B&#123;private: int a,b;public: B(A a): a(a.a),b(a.b) &#123;&#125;&#125; 这样子就可以解决问题了 如果你一定不要指针的话，也可以，那你可以把类内方法的实现放到两个类下面 123456789101112131415161718192021class B;class A&#123;private: int a,b;public: A(B *b)；&#125;class B&#123;private: int a,b;public: B(A a);&#125;A::A(B *b): a(b-&gt;a),b(b-&gt;b) &#123;&#125;B::B(A a): a(a.a),b(a.b) &#123;&#125; stl迭代器陷阱今天在用stl迭代经典算法时偶遇问题 果然像是这种问题，还是没有成体系学习stl甚至c++的锅。 iterator not incrementable vector iterators incompatible 这些问题碰到了很多次，原因这里简单记一下 迭代器在容器增加，删除时很容易失效，特别是erase函数，此时就会出现不兼容错误，因为此时迭代器的行为是不可预测的。 在使用memset时很容易弄坏几个指针，就会报错 解决方法 不使用memset简单粗暴操作 在敏感操作后的迭代器应该重新获得，可以存储偏移，也可以使用敏感操作的返回值重新获得 反思不再土法学习c++，继续系统化 类的静态变量需要定义 符号未定义…….static….. 如果出现这种问题，说明你没有定义类的静态变量。你至少需要在一个.cpp中定义一次 与普通便量不同，此处不会触发重定义 命令行程序的缓冲区有些人（我），为了程序看上去比较骚气 会使用 123_wsystem(L\"title 停车 -xxxx\"); // 宽字节版system(\"color F0\");system(\"mode con cols=36 lines=25\"); 这样的代码。 然后我们就会发现少了一个很重要的东西，滚条。 如果一屏幕放不下就看不见上面的数据了 解决方法12345#include......HANDLE con = GetStdHandle(STD_OUTPUT_HANDLE);COORD buf = &#123; 36,200 &#125;;SetConsoleScreenBufferSize(con, buf); 使缓冲区变大 缓冲区长度高于窗口时会有竖直的滚动条，反之反之，缓冲区应大于窗体 关于类的函数友元类的友元函数被类声明后。事实上就已经将此函数声明了。也就是这个函数是一个特殊的类方法。期望将独立于类的方法作为友元（即将别人的友元同时作为自己的友元声明）会在编译期报错。事实上 12345678910111213class A&#123;private: int a; friend void test();&#125;class B&#123;private: int a; friend void test();&#125;void test(); 这里的三个test是不同的test。位于不同的作用域 :: A:: B::，那么显然::A不能调用B::a。 这都是简单的东西，因为搞错了我们的ide都会报错。 但是如果test是A B中某类的操作符重载的话就会混淆ide，从而不报错 12345678910111213141516171819class A&#123;private: int a; friend A&amp;&amp; operator +(const A&amp; a, const A&amp; b); // 无用 没有A::A&amp;&amp; operator (const A&amp; a, const A&amp; b) +的定义&#125;class B&#123;private: int a; friend A&amp;&amp; operator +(const A&amp; a, const A&amp; b); // 无用 没有B::A&amp;&amp; operator (const A&amp; a, const A&amp; b) +的定义&#125;A&amp;&amp; operator +(const A&amp; a, const A&amp; b); // 有用 有::A&amp;&amp; operator (const A&amp; a, const A&amp; b) +的定义A&amp;&amp; operator +(const A&amp; a, const A&amp; b) // ::A&amp;&amp; operator (const A&amp; a, const A&amp; b) +的定义&#123; &#125; 没错,这里的operator +会被我们的vs识别为一个东西，甚至ctrl 点进去都是同一个，也就是下面的实现。然后你就会发现你可以使用A::a却不可以使用B::a，如果你水平和我一样菜的话，就会觉得很晕。 实际上，编译器只认最后面那个。上面的两个其实是被无视掉的，也就是被认为是只有声明没有定义的玩意。而函数可以使用A的私有变量其实是因为它是A的重载函数，c++给的语法糖罢了。 这里的原因是vs的bug，把三个A&amp;&amp; operator (const A&amp; a, const A&amp; b) +的声明都当成了::A&amp;&amp; operator (const A&amp; a, const A&amp; b) +。。。 其实和我菜也有一定关系。","categories":[{"name":"从零开始的编程之路","slug":"从零开始的编程之路","permalink":"https://www.intmian.com/categories/从零开始的编程之路/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://www.intmian.com/tags/编程/"},{"name":"c++","slug":"c","permalink":"https://www.intmian.com/tags/c/"}]},{"title":"ROP与ROP的实践","slug":"ROP","date":"2018-07-15T02:46:27.000Z","updated":"2018-07-30T08:13:48.518Z","comments":true,"path":"2018/07/15/ROP/","link":"","permalink":"https://www.intmian.com/2018/07/15/ROP/","excerpt":"Return-oriented programming（ROP）是一种很常见的攻击技术，是一种具有图灵完备性的超级攻击方式。","text":"Return-oriented programming（ROP）是一种很常见的攻击技术，是一种具有图灵完备性的超级攻击方式。 何为ROProp 即 面向返回的编程。上文我们讲到了ret2plt，rop就是ret2plt在64位的升级版本。rop也可以用来做32位的题，是一种相当上位的攻击技术。可以替代我们之前讲的几乎所有溢出利用。可以绕过aslr与dep(NX)。 我所理解的的ROP就是有去有回，需要多次劫持程序流的攻击。 广义的ROP包括了上文所讲到的任何返回式的攻击方式，不过我们今天要讲的是狭义的ROP 背景传参方式的改变在64位程序中，calling conventions规定参数依靠寄存器传递，前面6个参数依次以rdi, rsi, rdx, rcx, r8和r9寄存来传递，后面的参数则用栈来传递。这样子我们之前的那些依靠栈来传递参数的方法似乎就难以使用。 天然零化64位相较32位对于32位可以掌控更多（40亿倍，大约16EB）的内存。而我们显然用不到这么多内存（笔者连加一条8g内存都心痛），在linux中规定只使用后48位的内存，而前面的那些就全部置零，这些零字节会截断字符串，形成了天然的防护。 原理linux x64采用了寄存器传参，因此难以使用我们平时使用的栈传参。 参数 寄存器 1 RDI 2 RSI 3 RDX 4 RCX 5 R8 6 R9 由于我们不能直接控制寄存器。 我们上文讲到的ret2plt利用所谓的PPR结构来在libc或者其他的可执行块里找到一些片段来调用。 现在我们也用这种方法来进行攻击。将我们需要执行的指令连成ROP链来进行ROP攻击。 攻击步骤如何构建ROP链因为我们的攻击的最终目的一定是获得shell，所以我们最终需要让程序执行system(&quot;\\bin\\sh&quot;)这条指令。那就需要覆盖程序返回地址到我们想要执行的地方。 buffer|canary|saved fame pointer|saved returned address 那么我们需要在栈里面写入”/bin/sh\\0”。因为栈的内容是我们可以控制的，所以可以写入。那么我们需要找到例如pop rdi这样的语句。我们可以使用诸如ROPgadget这样的工具，具体用法请看官方文档。 但是有一点需要注意，我们找到的语句必须包含一个返回ret(retq)，不然会顺着语句一路执行下去。 当然，我们有些时候会碰到程序过于小，导致根本没有rop片段可以利用，例如上次笔者碰见的一个500b的题，那我们需要利用libc的gadget，但是我们一般情况下不知道题目的libc，所以需要不断leak出服务器端的libc。 如果对于libc的地址，aslr等不是很清楚的话，建议再读一读elf的内容。 ROP的功能rop看似复杂，限制很多。但是总可以从程序中找到一枝半叶，而组成极其强大的功能。rop真的可以为所欲为。 甚至，高手的rop可以实现循环、分支、条件等等逻辑。有人指出rop具有图灵完备性。 局限 技巧性有点强。 需要其他的栈溢出或者注入来做铺垫。","categories":[{"name":"从零开始的ctf之路","slug":"从零开始的ctf之路","permalink":"https://www.intmian.com/categories/从零开始的ctf之路/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.intmian.com/tags/pwn/"},{"name":"栈","slug":"栈","permalink":"https://www.intmian.com/tags/栈/"}]},{"title":"巧绕NX与ascii armoring-ret2plt","slug":"巧绕NX与ascii-armoring-ret2plt","date":"2018-06-15T13:01:55.000Z","updated":"2019-01-24T05:07:05.999Z","comments":true,"path":"2018/06/15/巧绕NX与ascii-armoring-ret2plt/","link":"","permalink":"https://www.intmian.com/2018/06/15/巧绕NX与ascii-armoring-ret2plt/","excerpt":"前面讲完了plt、got，我们来个相关的。","text":"前面讲完了plt、got，我们来个相关的。 前言前排广告位招租最近忙于乱七八糟的事，导致没时间更博客。除了开发方面，bin方面也需要多多努力，避免被别人远远甩在后面 ret2pltascii armoring为了针对1997年的黑客提出的 return-to-libc 技术，ascii morning被提出，以将libc的函数地址的第一个字节进行零化的方式阻止了system地址被写入栈中导致程序流被劫持到了libc中奇怪的地方，从而拿到shell。 零字节可以截断字符串使黑客无法将system地址写入栈。 思路还记得我们是怎么写shellcode的嘛，就是千方百计地通过各种方式搞出零字节。这次我们也要使用这种精神。 为了对抗ascii armoring我们不再使用libc中的函数，我们使用plt中的strcpy一点点的把system的地址拼接出来,写入plt表中的某个函数的空间中。最后再劫持程序流到这个空间中去，从而拿到shell。 这就有一个问题，我们都知道开了NX之后程序不再可以在栈中执行shellcode，这让需要执行这么多strcpy的我们感觉很麻烦。因此我们通过一种被称为 PPR 的技术，这样子我们就可以连续地执行多个函数。 PPR由两个pop、和一个ret组成，专门负责清空两个已经用过的参数（plt表中需要写入的东西与需要被写入地system地址的一部分）并且用ret返回到下一个参数中去。 假定有 （堆栈中的内容） strcpy@plt system[0] xxx@plt[0] PPR的地址 strcpy@plt &lt;--------EIP指向这里 （某处） pop eax &lt;--------PPR的地址 pop eax ret 我用文字来描述一般 程序流走向了strcpy@plt这里后把PPR的地址当成函数的返回地址并把system[0]和xxx@plt[0]当成了函数的两个两个参数运行 执行完了strcpy后ret返回了某处的PPR源码中，然后通过两个pop eax将两个参数从栈中清除出去（通过增加了esp的值到了两个参数下面），然后通过ret，取出下一个strcpy的地址，并控制程序流到了那里。 返回第一过程。 这样子我们就通过预先的栈溢出来控制程序的连续走向不同的plt表中的函数，来达成一个非常复杂的功能，而不是像ret-libc那样只能达成一个单独的函数的功能 PPR技术主要是为了清除参数，在其他情况中如果没有参数则不需要PPR技术只需把下一个函数的地址填入返回地址中 过程 我们需要从栈中注入如上图大小的块 但是我们还有几个技术问题没有解决 PPR的代码放在哪里？ strcpy在plt表中的位置 system的地址在哪里？ 放在plt表的哪里 /bin/bash放在那里 我们按照一步步流程来 对准EIP这个打开ida可以解决问题或者用我们的gdb调一调也可以解决。 找到strcpy的位置可以通过ida来反编译函数来获得地址（没开aslr的情况）。 找到PPR的地址我们唯一可以控制的空间只有栈和plt表，而对后者的控制是建立在PPR的地址已经找到了上。那我们就不能自由的注入PPR了。索性这种平衡栈帧的代码非常（并不）常见。我们去可执行段里随便找一个，然后拿来用。 system的拷贝由于ASCII armoring机制，system的地址含有零字节，造成strcpy拷贝结束，达不到预期的攻击效果。攻击者找到4个地址空间，它的首字节分别是system地址的第一个byte, 第二个byte，第三个byte和第四个byte，然后一个个byte拷贝，将这4个byte拼凑到GOT里面。从而绕过直接拷贝system地址造成失败。 时下最流行的ubantu没有这个特性哦。 我们强行逆一波，然后在内存里找到，然后在记在小本本上。 需要注意，虽然说我们都是经验并不丰富的攻击者，但是还需要特别注意一下，需要找的是内存中存放的字节，而不是字节的ascii码。 也可以使用find命令在内存中找。为了精确定位，我们应当在内存镜像中寻找以避免地址在加载中偏移,形如find /b 0xaaaaaaaa, 0xbbbbbbbb, 0xcc的gdb命令可以在a…到b…的空间内写入cc。 内存镜像的工作原理与硬盘的热备份类似，内存镜像是将内存数据做两个拷贝，分别放在主内存和镜像内存中。 写入哪个plt表空间为好呢？看了我前文的内容你是否有疑惑，我用的strcpy并不是一个字符拷贝函数，而是字符串拷贝函数，也就是说这四个字符的位置可能会溢出，盖掉其他的plt表项，其中可能就包括strcpy。这就让我们需要选一个trycpy前面的，我就随便选个puts吧。 逆一波程序就可以拿到puts的地址了。 本文使用了puts作为目标地址，你当然可以选择其他的。 “\\bin\\bash”的地址同样的，为了精确攻击，我们最好找一个现成的。 Linux里面有个shell环境变量，表示前使用哪个shell，它的值通常是”/bin/bash”，如下： $ env | grep -i shellSHELL=/bin/bash 每个进程的环境变量都保存在主线程的栈上，因此可以在主线程栈空间上找到该字符串。由于本文的代码为单线程 ，因此可以沿着esp地址往上找即可： (gdb) x/1000s $esp … 0xffffd8b4: &quot;/home/ivan/exploit/stack4&quot; 0xffffd8ce: &quot;SHELL=/bin/bash&quot; 0xffffd8de: &quot;TERM=xterm&quot; … 环境变量也是作为参数传进主程序的。 攻击向量根据上面的方法我们可以得出我们需要注入的内容。 A*xstrcpy@plt + PPR + puts@got[0] + addr of system[0]strcpy@plt + PPR + puts@got[1] + addr of system[1]strcpy@plt + PPR + puts@got[2] + addr of system[2]strcpy@plt + PPR + puts@got[3] + addr of system[3]puts@plt + exit + addr of “/bin/bash” 局限 需要确切的地址难以对抗aslr防护。 需要过于多的条件，难以满足多变的情况。 在内存中需要寻找过于多的地址。 需要注入plt表的值，在64位天然零化的情况下难以为继 与ROP技术相比，不具备完备性，局限性太强 正因为许许多多的漏洞导致了ret2plt并没有流行起来。","categories":[{"name":"从零开始的ctf之路","slug":"从零开始的ctf之路","permalink":"https://www.intmian.com/categories/从零开始的ctf之路/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.intmian.com/tags/pwn/"},{"name":"栈","slug":"栈","permalink":"https://www.intmian.com/tags/栈/"},{"name":"plt&got","slug":"plt-got","permalink":"https://www.intmian.com/tags/plt-got/"}]},{"title":"堆与最基本的堆溢出-fastbin","slug":"最基本的堆溢出-fastbin","date":"2018-06-14T11:04:15.000Z","updated":"2018-07-01T07:59:13.911Z","comments":true,"path":"2018/06/14/最基本的堆溢出-fastbin/","link":"","permalink":"https://www.intmian.com/2018/06/14/最基本的堆溢出-fastbin/","excerpt":"一些关于堆的小知识和基本的利用 fastbin","text":"一些关于堆的小知识和基本的利用 fastbin 基础知识内存上的空间会被划分为若干个chunk chunk包括以下两种： 已分配的堆块： chunk-&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if allocated | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |M|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) . . | nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 未分配的堆块： chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `head:&apos; | Size of chunk, in bytes |P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . . . . | nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `foot:&apos; | Size of chunk, in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 它们的各个参数意义分别是： prev_size: 如果当前chunk的相邻前一chunk未被使用，prev_size为此前一chunk的大小size: 当前chunk的大小。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息。我们需要记住的便是最低bit，即图中P的位置，用于指示前一chunk是否已被使用(PREV_INUSE)。 如果当前chunk处于未被使用状态，则mem前8 bytes被用来存储其他信息，具体如下：fd: 下一个未被使用的chunk的地址bk: 上一个未被使用的chunk的地址 可以看到，chunk头中包含的大小信息，主要用来在获取内存中相邻chunk的地址（当前chunk地址减去前一chunk的大小，为前一chunk的地址；当前chunk地址加上当前chunk的大小，为后一chunk的地址）。而mem中的fd和bk只在当前chunk处于未被使用时才有意义，因为当我使用了此chunk后mem里的空间被用来存储数据。通过这些未被使用的fd、bk chunk组成了一张链表。通常差不大小的chunk会被放在一起组成一张链表，其被称为bin。bin的集合被malloc合并，被称为bins。 fastbin维护一大堆的链表，当申请较小内存空间时它们会被从fastbin中剪除，并返回此地址。在free时，为了快速回收这些空间，将不通过bk仅由fd将chunk插进fastbin。并且其满足后进先出的原理 fastbin由于fastbin没有bk，是一个单向链表，因此可能会触发任意写的问题。 fastbin中的东西实际上是通过在内存上连续排布来实现的。当堆栈顶部的chunk被出栈以后实际上fastbin会指向次chunk的上一个。 此过程是通过fastbin中此大小的指针指向chunk的fd来实现的。所以如果fd被通过某种技术覆写，那么malloc就会返回被覆写入的地址。如果mem被丢入一个十分大的数据就会把下面的覆写了，这会导致再进行两次malloc就会返回你所定义的伪chunk中的内容。 这个伪chunk会指向你需要的任意地方，利用这种指针可以触发任意写","categories":[{"name":"从零开始的ctf之路","slug":"从零开始的ctf之路","permalink":"https://www.intmian.com/categories/从零开始的ctf之路/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.intmian.com/tags/pwn/"},{"name":"堆","slug":"堆","permalink":"https://www.intmian.com/tags/堆/"}]},{"title":"格式化字符串漏洞","slug":"格式化字符串漏洞","date":"2018-06-14T11:04:15.000Z","updated":"2019-01-24T05:07:11.082Z","comments":true,"path":"2018/06/14/格式化字符串漏洞/","link":"","permalink":"https://www.intmian.com/2018/06/14/格式化字符串漏洞/","excerpt":"printf家族的格式化漏洞","text":"printf家族的格式化漏洞 原理格式化字符串漏洞主要出现在printf家族中，当程序员为了偷懒将从用户处读入的字符串直接输出时，可能会触发格式化字符串漏洞，例如以下代码。 printf(&quot;%s&quot;,str)//这是安全的 printf(str)//这是危险的 虽然说printf的第一个参数一定会输出，但是如果在其中拥有格式字符的话，就会从堆栈中找到一个变量的参数值进行输出，从而输出本不应该输出的内容。 引例以下我将把一段c++代码作为例子解析原理 #include &lt;iostream&gt; using namespace std; int main() { char str[100]; cin &gt;&gt; str; printf(str); system(&quot;pause&quot;); } 这段代码就会出现此类bug %s閴J 其中“閴J”这个奇怪的字符串就是从内存里读出来的假如我们不使用%s这样的目的较纯粹的格式化字符，而是使用%n、%x这样恶意满满的格式化字符就会导致任意写或者堆栈中的东西被泄露出去。 %x查看栈的内容%s查看地址上的内容内容如下 %x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s -—-结果—- 11d108211d10825b1000cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc7825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325732573257325000000000000(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null)(null) ps.请注意这样子操作访问的地址从高到低（堆栈从低向高利用）一个%x刚好跳过一个地址。 sprint触发栈溢出例如 char user[]=&quot;%496d\\x39\\x4a\\x42\\x00&quot;; char outbuf[512]; char buffer[512] sprintf(buffer,&quot;ERR Wrong command：%.400s&quot;,user); 两个16进制表示一个字符，以这种方式将他们捆成整体，这样子会两个16进制会作为一个整体写入而不是作为两个字符写入毕竟我们需要在内存中写入的是00434a39而不是16个16进制。也只有以这种方式才能在内存中写入00434a39 这里有一个小技巧利用%496d，快速向buffer里面丢垃圾这样子就往栈中存放eip的位置写入了“00434a39” 低&emsp; 临时变量3 EBP-xxx↓↓&emsp; 临时变量2 EBP-xxx↓↓&emsp; 临时变量1 EBP-xxx↓↓&emsp; &lt;——EBP↓↓&emsp; EBP原值↓↓&emsp; EIP原值↓↓&emsp; 参数1↓↓&emsp; 参数2高&emsp; 参数3 调用函数附近的内存情况 任意内存写先通过这样的方式确定那个字符串放在那里输入AAAA %08x %08x %08x %08x %08x %08x %08x \\x58\\x74\\x04\\x08%.Md%n形如这样的代码可以在08047458中写入一个M+4大致原理基本如此 pentools 可以很快速的进行此漏洞利用，下次有空补上","categories":[{"name":"从零开始的ctf之路","slug":"从零开始的ctf之路","permalink":"https://www.intmian.com/categories/从零开始的ctf之路/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.intmian.com/tags/pwn/"}]},{"title":"bin实用小工具","slug":"实用小工具","date":"2018-06-14T11:04:15.000Z","updated":"2018-07-01T07:59:13.708Z","comments":true,"path":"2018/06/14/实用小工具/","link":"","permalink":"https://www.intmian.com/2018/06/14/实用小工具/","excerpt":"一些bin学习过程中常用的工具","text":"一些bin学习过程中常用的工具 环境glibc版本&lt;= 2.23 bin必要工具：Ubuntu:https://mirrors.aliyun.com/ubuntu-releases/16.04/你大可换其他的，例如kali windows：不解释 IDA7.0:链接：https://pan.baidu.com/s/1s9K1TurV_bvlnWAAGJ4z-g 密码：1e9i 没有IDA不知道怎么做bin题。。。 pwn必要工具：pwntools:apt-get updateapt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialpip install –upgrade pippip install –upgrade pwntools pwn题必备，使用方法可以百度下，很容易找到的 Pwngdb:链接：https://pan.baidu.com/s/1XtbuCfh_09ahlNAdly-KcA 密码：mfz0 gdb的插件，简直是太好用了 msfvenom:https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers shellcode生成工具，可以生成各种要求的shellcode，蛮好用的 roputils:https://github.com/inaz2/roputils 和pwntools一起导入可能有点问题，一开始可能用不到，我用这个做过dl-resolve的题 ROPgadget:https://github.com/JonathanSalwan/ROPgadget ROP基本也是做pwn必备的东西，用法看自行看readme Re必要工具：听逆向大神说好像一个IDA可以走天下了……此外还需要用到OD。偶发性地，还需要一些小工具。 建议安装吾爱破解工具包，再把里面的IDA等更新到最新版本。 小建议： 有余力的朋友建议购买正版。 要下载github上的东西，可以在虚拟机里输入 git clone +项目地址","categories":[{"name":"从零开始的ctf之路","slug":"从零开始的ctf之路","permalink":"https://www.intmian.com/categories/从零开始的ctf之路/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.intmian.com/tags/pwn/"},{"name":"re","slug":"re","permalink":"https://www.intmian.com/tags/re/"}]},{"title":"linux上的链接","slug":"linux上的延迟重定位","date":"2018-06-14T11:04:15.000Z","updated":"2019-01-03T12:57:24.699Z","comments":true,"path":"2018/06/14/linux上的延迟重定位/","link":"","permalink":"https://www.intmian.com/2018/06/14/linux上的延迟重定位/","excerpt":"linux上的软链接与硬连接","text":"linux上的软链接与硬连接 前言按照计划我应当更新绕过NX的一些攻击方式，但是我觉得既然讲了绑定，那就顺便来讲讲有关于链接的话题吧。 linux内部文件管理在现代操作系统中，文件的意义是使信息独立于进程长期存在。而为了方便文件被多个进程相互独立的调用，linux系统设置了一组通用的api来对文件或其他被看作文件的东西进行操作。也就是说linux把所有除了进程以外的东西全部当成文件。 文件的操作是通过所谓的字节流来进行。而上文提到的通用的api就是来管理与操作这些字节流的，最常见自然是对文件或者屏幕（终端的用户输入）进行管理的api。并且，为了方便进行管理这些文件，linux使用了文件夹这一系统。 在linus写linux的最初版本时文件夹还不是一项必须要实现的功能，例如大名鼎鼎的unix系统就不能实现这个功能。 如果有细心的朋友在根目录下ls -a,就会发现有很多文件夹 / 根目录 ├── bin 存放用户二进制文件 ├── boot 存放内核引导配置文件 ├── dev 存放设备文件 ├── etc 存放系统配置文件 ├── home 用户主目录 ├── lib 动态共享库 ├── lost+found 文件系统恢复时的恢复文件 ├── media 可卸载存储介质挂载点 ├── mnt 文件系统临时挂载点 ├── opt 附加的应用程序包 ├── proc 系统内存的映射目录，提供内核与进程信息 ├── root root 用户主目录 ├── sbin 存放系统二进制文件 ├── srv 存放服务相关数据 ├── sys sys 虚拟文件系统挂载点 ├── tmp 存放临时文件 ├── usr 存放用户应用程序 └── var 存放邮件、系统日志等变化文件 其中的home文件夹就是我们平常所使用的最多的文件夹。 笔者认为Linux在系统文件的隐藏，这一方面做的比windows高得多。虽然windows的文件夹目录更为直观，但是同时也产生了用户很容误删这些关键的系统文件的问题。 当然windows其它方面的易用性与生态会把linux秒成渣。 但这又有什么用呢，服务器是linux的，你还不是老老实实得需要用linux做pwn题 需要注意的是因为万物皆为文件的设计，所以linux中的文件夹并非与windows一样，是一个高于普通文件的顶层设计的产物，而是一种特殊的文件。 使用命令 mkdir 创建目录时，若期望创建的目录的名称与现有的文件名（或目录名）重复，则会创建失败。 Linux 将设备当做文件进行处理下面这段终端记录展示了如何打开设备文件 /dev/input/event5 并读取文件内容。文件 event5 表示一种输入设备，其可能是鼠标或键盘等。查看文件 /proc/bus/input/devices 可知 event5 对应设备的类型。设备文件 /dev/input/event5 使用 read() 以字符流的方式被读取。结构体 input_event 被定义在内核头文件 linux/input.h 中。 1234567int fd;struct input_event ie;fd = open(\"/dev/input/event5\", O_RDONLY);read(fd, &amp;ie, sizeof(struct input_event));printf(\"type = %d code = %d value = %d\\n\", ie.type, ie.code, ie.value);close(fd); 从这里可以看出设备可以作为文件来进行读写。 硬链接与软链接虽然文件这一数据结构的作用是存放数据，但是显然，它也存放了一些与这些数据相关的另一些数据，例如创建时间，文件名等信息。 插一些题文无关的内容，文件并不以文件名来作为系统中的唯一标识，而将文件的 inode 号作为文件的唯一标识。就和windwos系统中不以进程名而已句柄来分辨进程其实是一个道理。 一般来说将我们将这两种数据称作 用户数据 元数据 需要注意的是，进程对于文件其实是非独占的。换言之，多个进程可以使用同一个文件。文件的共享是一个难题。可以想象，如果说没有限制的使用同一个文件会导致读取方面产生多大的问题。 为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与 软链接（又称符号链接，即 soft link 或 symbolic link）。 链接的作用有 解决了文件的共享使用 隐藏文件路径 增加权限安全 节省存储空间 … 上文也提到了linux系统下有文件夹这一个架构，那么如果我们需要在不同的文件下同时保留一个文件，我们当然可以简单的直接拷贝一份，但是这样浪费了大量的空间，而且在程序真正需要去改变文件的数据时会导致多个文件的数据不同步，丢失了我们复制一份的初衷。 我们需要一种结构，在改变它的数据时同时会改变原始的数据，而且占用空间小。 最优的解决方案就是： 只有一个真实存在的文件 在其他文件夹下存放的数据其实只是这个文件的别名。 这就是 硬链接 ，硬链接就是一个文件的不同的文件名。可以为一个inode号创建不同的文件名，而这些文件名可以和现实中存在文件一样被程序读写。私以为它和c++的指针特别像 当然我们也可以创建和windows中快捷方式一样的东西，这就是 软链接 。软链接是现实中存在的文件，它也有着所谓的元数据与用户数据。但是它的数据块有着些许不同，它存放的是另一个文件的地址。 连接的创建硬链接硬链接可以用以下指令来创建 link oldfile newfile ln oldfile newfile 此外需要注意，不要向目录创建硬链接 但是有以下注意事项 文件有相同的 inode 及 data block； 只能对已存在的文件进行创建； 不能交叉文件系统进行硬链接的创建； 不能对目录进行创建，只可对文件创建； 删除一个硬链接文件并不影响其他有相同 inode 号的文件。 软链接硬链接可以用以下指令来创建 link -s oldfile newfile ln -s oldfile newfile 此外 软链接有自己的文件属性及权限等； 可对不存在的文件或目录创建软链接； 软链接可交叉文件系统； 软链接可对文件或目录创建； 创建软链接时，链接计数 i_nlink 不会增加； 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接） 删除rm,没啥好说的。 后记文章拖了好久了，以后还是要多加努力。","categories":[{"name":"从零开始的ctf之路","slug":"从零开始的ctf之路","permalink":"https://www.intmian.com/categories/从零开始的ctf之路/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.intmian.com/tags/linux/"}]},{"title":"unlink","slug":"unlink","date":"2018-06-14T11:04:15.000Z","updated":"2018-07-01T07:59:13.708Z","comments":true,"path":"2018/06/14/unlink/","link":"","permalink":"https://www.intmian.com/2018/06/14/unlink/","excerpt":"一些堆溢出方面的关于unlink的知识","text":"一些堆溢出方面的关于unlink的知识 原理glibc中间维护的bins其实是用来存放malloc时从heap中割下来的堆,为了避免在heap中割下了太多的连续的free chunk，系统会将free chunk自动合并到top chunk中去（top chunk指系统heap中最高位未分配的那个chunk）或者合并成为更大的一个chunk。 条件：相邻的两块chunk 一块为top chunk 一块为free chunk 或者两块两块 free chunk。所以我们要做的是先连续割两块chunk，保证他们是连续的，以保证他们会unlink。 在溢出时之所以要覆写p位，就是为了能够触发unlink 流程：如果上一块是free chunk&emsp;&emsp;合并上一块chunk并对上一块做unlink如果下一块是&emsp;&emsp;top：合并到top&emsp;&emsp;一般chunk：&emsp;&emsp;&emsp;&emsp;是free chunk：合并下一块chunk，并对下一块做unlin。最终加入unsortedbin&emsp;&emsp;&emsp;&emsp;正在使用中：加入unsortedbin 最终结果所有的同样大小的free chunk递归合并 例子假定有三块连续的smallchunk第一块第二块freed，第三块issued。***prevsize = 0size = 0x80fd = &amp;smallbinbk = &amp;smallbin***prevsize = 0size = 0x80***prevsize = 0size = 0x81(p位+1代表上一块已经使用已经使用)*** free(p)(第二块),就会导致一二两块合并，从而触发unlink系统检验p+size 与p-prevsize得到了上下两个块的头 p+0x10为FD，p+0x18为BK unlink(P,FD,BK) { P = p FD = P -&gt; BK BK = P -&gt; FD FD -&gt; BK = BK BK -&gt; FD = FD } 相当于将这个块从bin中脱链。然后系统会将上一个块更改size之类的，然后链到unsortedbin上。 预期利用方式将程序劫持到shellcode中 shellcode是一段用于利用软件漏洞而执行的代码，以其经常让攻击者获得shell而得名。 shellcode常常使用机器语言编写。 利用unlink导致返回了weichunk中指向的地址。最后触发任意写，将必须触发的函数在got表中值改到shellcode，或者更改函数指针变量的值导致触发system()。 利用思路:首先很直观地想到通过堆溢出q堆盖掉后面的FD和BK，将fd改为gou entry -12，将bk 改为 shellcode 的地址，将size低位改为1。在free(q)时会发生如下过程： free(q) FD = P-&gt;fd = got entry -12 BK = P-&gt;bk =sc(shellcode) addr FD-&gt;bk=BK(got hijacking) got entry -12 +12 = sc addr BK-&gt;fd=FD sc addr+8=got entry -12 在此过程后，会会进行一次任意写将FD+0x10的地方写入shellcode然而在现实情况中，现代的glibc会有着针对chunk的检查以及其他保护机制，使得该方法无法使用。因此我们的利用方式是***prevsize = 0size = 0x80 ***prevsize = 0size = 0x91&lt; r指向此处&gt;***prevsize = 0size = 0x80(p位+1代表上一块已经使用已经使用)&lt; q指向此处&gt;***通过对于第二个chunk进行堆溢出将第二个块整体盖掉然后在其中伪造一个chunk并且改写第三个堆块的prev_size最后变为***prevsize = 0size = 0x80 ***prevsize = 0size = 0x91fake prev_size = 0x90&lt; r指向此处&gt;fake size = 0x80fake fd = &amp;r-0x18fake bk = &amp;r-0x10***prevsize = 0x80size = 0x80(p位+1代表上一块已经使用已经使用)&lt; q指向此处&gt;***这样子在可以绕过两个检查，成功将r并入了chunk中从而进行任意写。具体流程：free(q)找到q与r都是freed找到了最下面的q，通过q-0x10找到的prev_size。q-0x10-prev_size找到r。对于r执行unlink跳过了check：r-&gt;fd-&gt;bk == r = (&amp;r-0x18+0x18) ==rf-&gt;bk-&gt;fd == r = (&amp;r-0x18+0x18) ==r FD-&gt;bk = BK =》（&amp;r-0x18+0x18）=&amp;r-0x10BK-&gt;fd = FD =》（&amp;r-0x10+0x10）=&amp;r-0x18 大功告成","categories":[{"name":"从零开始的ctf之路","slug":"从零开始的ctf之路","permalink":"https://www.intmian.com/categories/从零开始的ctf之路/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.intmian.com/tags/pwn/"},{"name":"堆","slug":"堆","permalink":"https://www.intmian.com/tags/堆/"}]},{"title":"linux上的延迟重定位","slug":"linux-banding","date":"2018-06-14T11:04:15.000Z","updated":"2018-07-01T07:59:13.708Z","comments":true,"path":"2018/06/14/linux-banding/","link":"","permalink":"https://www.intmian.com/2018/06/14/linux-banding/","excerpt":"熟练地掌握linux的 链接与 绑定不仅仅是研究return to plt的必要，更是掌握linkmap、got表覆写、dlresolve等技术的基础","text":"熟练地掌握linux的 链接与 绑定不仅仅是研究return to plt的必要，更是掌握linkmap、got表覆写、dlresolve等技术的基础 主题 plt、got表 延迟绑定 软硬链接 文件外函数的调用原理函数调用的汇编实现假如有这样一个代码system(&quot;cat flag&quot;) 在程序流流向这里的时候会发生什么样的事情呢？ 我事先写好了一个这样的程序。让我们拖到ida里面好好看一看。 push offset command ; &quot;cat flag&quot; call _system add esp, 10h 可以看见他调用了_system，这个_system和libc里面的system不是一个东西。 我们点开_system可以看见 .plt:08048410 ; =============== S U B R O U T I N E ========================= .plt:08048410 .plt:08048410 ; Attributes: thunk .plt:08048410 .plt:08048410 ; int system(const char *command) .plt:08048410 _system proc near ; CODE XREF: main+163↓p .plt:08048410 .plt:08048410 command = dword ptr 4 .plt:08048410 .plt:08048410 jmp ds:off_804A014 .plt:08048410 _system endp .plt:08048410 .plt:08048416 ; -------------------------------------------------------------- 我们发现了这里面有着plt三个字，这就是所谓的plt表中的一部分。 再点开 ds:off_804A014 我们就会发现 .got.plt:0804A014 off_804A014 dd offset system ; DATA XREF: _system↑r 我们发现了这里面有着got三个字，这就是所谓的got表中的一部分。 生成汇编为什么需要有plt与got这些东西，而不在程序中直接call system这样的方法来访问system，的原因在于system是在glibc库中，而glibc属于动态库。 如果读者了解过windows的动态链接库的话，事实上这两者有所区别，但是大致原理基本相似 之所以无法直接直接call system，这正是用为程序中调用system的代码是在编译和链接中（事实上主要在编译中）确立的，而在此过程中，system的地址，编辑器无从而知。而在现代操作系统中，代码段也无法更改，所以试图在加载过程call aaaaa改为call xxxxx(&amp;system)也是无用功。 同时因为编辑器同时无法确定system函数是在libc这样的动态库中还是在其他的中间文件（.o）中所以编辑会生成一样格式的代码，这使得无论你的某函数是在动态链接库中还是在其它文件中给出定义，这样的汇编代码都能实现调用system。 重定向但是函数的调用总归是需要函数的具体地址的。那么就可以把情况分为两种。 静态链接库 动态链接库（如glibc） 在这两种情况中： 前一种函数的位置在编译过程中是已知的，所以在编译过程中可以计算出在编译过程中填进去占位的地址距离程序在被载入后此函数位置的偏移量，并将其填入某个位置。这就是 链接时重定位。 后一种函数的位置在运行时是已知的，算出偏移量中也填入此表中。这就是 运行时重定位。 函数的调用在完成了重定向之后，函数的调用还面临着一个问题。那就是，在无法改变代码段的情况下，应当如何利用数据段中的偏移量呢。 答案是程序在链接中就生成一小段专门利用偏移量的代码。 链接器生成额外的伪代码如下： .text ... // 调用system的call指令 call system_stub ... system_stub: mov rax, [system函数的储存地址] ; 获取system重定位之后的地址 jmp rax ; 跳过去执行system函数 .data ... system函数的储存地址 ;这里储存system函数重定位后的地址 在链接的过程中，如果发现函数实际上是动态链接库的代码，就会添加以上代码，并将system改为system_sub。 所以实际上在函数的调用中我们需要两样东西 需要存放外部函数的数据段 获取数据段存放函数地址，并且正确的访问他们的一小段额外代码 又因为动态库的函数往往不止一个所以许多这样的数据段与许多这样的代码形成了两张表。存储函数相对地址的表叫做 全局偏移表，即 got表,而存储那段额外的代码的表被叫做 程序链接表，即 plt表。 延迟重定位前文提到了函数的地址放在got表中，所以把got中的数据段填充满必须优先于调用之前， 延迟重定位，故名思意，一大特点是 延迟。 延迟即尽可能的延迟，直到不得不执行为止。之所以linux会有这样的特性，是因为如果动态库函数非常之多，那么放在前面一起执行会大大地减弱程序的启动时间。所以linux使用延迟重定位机制来使载入动态库地时间被均匀分散到了执行时间中。 这就产生了一个问题：程序如何知道GOT表中某一数据项是否已经被载入（因为程序中的函数可能会被执行多次，这样子就不必每一次都去重定位了）。 在程序中地具体实现大致为 void system@plt() { address_good: jmp *system@got // 链接器将system@got填成下一语句lookup_system的地址 return； lookup_system: 调用重定位函数查找system地址，并写到system@got goto address_good; } 当第一次运行system函数时，程序流会跳到system@plt，然后会顺势执行jmp *system@got，但是很显然，got表中的数据项并没有填充正确的值。其实程序流并没有前往所谓的system@got，实际上它前往了lookup_system中去，这个函数的功能是调用重定位的函数来寻找system的函数地址，并将其写入system@got中去，然后再跳到addr_good，执行system然后返回到调用者。这样子下面的lookup_system就相当于被废除了。 然后在第二次调用system时，就直接走向system的真正的地址中。 事实上重定位中的最后实现并没有每一个plt中都含有符号解析与重定位的那一部分。所以程序中实现具体实现为。 jmp *system@got push id(当前函数在plt中的偏移量/2) jmp common@plt 公共plt的具体实现在上文中我们基本缕清了函数重定向的前世今生与大致实现方式。接下来我要重点讲一下这个公共的函数的实现方式。 我们先在ida里看看这个函数的具体实现，在这里ida的F5已经无能为力了，我们硬刚下源码试试 .plt:08048300 common proc near ; CODE XREF: .plt:0804831B↓j .plt:08048300 ; .plt:0804832B↓j ... .plt:08048300 ; __unwind { .plt:08048300 push ds:dword_804A004 .plt:08048306 jmp ds:dword_804A008 .plt:08048306 common endp 很显然这个所谓的804A008就是所谓的重定向函数，而上面的804A004，就是参数。 而在这些地方放的就是 .got.plt:0804A004 dword_804A004 dd 0 ; DATA XREF: common↑r .got.plt:0804A008 ; int (*dword_804A008)(void) .got.plt:0804A008 dword_804A008 dd 0 ; DATA XREF: common+6↑r 在下面我们发现了 .got.plt:0804A00C off_804A00C dd offset read ; DATA XREF: _read↑r .got.plt:0804A010 off_804A010 dd offset __gmon_start__ .got.plt:0804A010 ; DATA XREF: ___gmon_start__↑r .got.plt:0804A014 off_804A014 dd offset __libc_start_main .got.plt:0804A014 ; DATA XREF: ___libc_start_main↑r .got.plt:0804A018 off_804A018 dd offset write ; DATA XREF: _write↑r .got.plt:0804A018 _got_plt ends .got.plt:0804A018 发现接着跑下去就已经看不懂了 随手点一个进去 extern:0804A034 extrn write:near ; CODE XREF: _write↑j extern:0804A034 ; DATA XREF: .got.plt:off_804A018↑o 好像是一个声明一样的东西。 经过了观看大神写的微博以后，我发现如果使用gdb进行动态调试的话，这个common，在没有进行运行时，其的值为0x0，在运行后会变成它的值会变成另一个值，而这个值最终指向的是 _dl_runtime_resolve,而这一个处于动态链接器中的函数。 _dl_runtime_resolve因为每一个plt表里的函数都需要调用这个公共的dlresolve项，所以dlresolve得知道需要查找的是哪一个函数，并将GOT表的值写在哪个函数的plt段。因为在plt表里push了一个参数，我上面也写了你如果去算算的话，它与函数在plt表中的偏移量相同 在程序内部，维持有一个重定位信息表。利用readelf -r test,可以看见.rel.plt段中的消息 Offset Info Type Sym.Value Sym. Name 080496f8 00000107 R_386_JUMP_SLOT 00000000 puts 080496fc 00000207 R_386_JUMP_SLOT 00000000 __gmon_start__ 08049700 00000407 R_386_JUMP_SLOT 000000000 __libc_start_main 程序可以通过这个公共的offset表，找到应当被填写GOT表函数的地址的位置。 其实想要彻底搞清楚这个过程还需要对于elf文件在linux系统的装载有着更深的理解才行，所以我这边的讲解只是浅尝辄止不深究了。 日后讲解这个dlresolve的时候还会像详细讲解这个过程与可能的利用。","categories":[{"name":"从零开始的ctf之路","slug":"从零开始的ctf之路","permalink":"https://www.intmian.com/categories/从零开始的ctf之路/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.intmian.com/tags/linux/"},{"name":"plt&got","slug":"plt-got","permalink":"https://www.intmian.com/tags/plt-got/"}]},{"title":"pwn的杂记","slug":"pwn的小知识的杂记","date":"2018-06-14T11:04:15.000Z","updated":"2018-07-28T01:02:02.380Z","comments":true,"path":"2018/06/14/pwn的小知识的杂记/","link":"","permalink":"https://www.intmian.com/2018/06/14/pwn的小知识的杂记/","excerpt":"这是我的一些pwn的随笔","text":"这是我的一些pwn的随笔 先讲一些关于pwn的术语吧 payload（有效攻击负载）是包含在你用于一次漏洞利用（exploit）中的ShellCode中的主要功能代码 shellcode（可提权代码） 对于一个漏洞来说，ShellCode就是一个用于某个漏洞的二进制代码框架，有了这个框架你可以在这个ShellCode中包含你需要的Payload来做一些事情 exp (Exploit )漏洞利用，一般是个demo程序 poc.(Proof of Concept)漏洞证明，一般就是个样本 用来证明和复现 vul：(Vulnerability) :漏洞”Pwn”：是一个黑客语法的俚语词 ，是指攻破设备或者系统 gdb-peda 使用中的常用技巧可以使用pattern_create()创建一个形如 pattern_create(200)‘AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAnAASAAoAATAApAAUAAqAAVAArAAWAAsAAXAAtAAYAAuAAZAAvAAwA’ 的字符串，把他输入进程序就可以得到eip被误占所引发的错误。再用pattern_offset 输入出错信息里的地址，就可以算出距离首地址的偏移在简单的栈溢出中应当在覆盖完所有的临时变量后再顺便把bp（x86 4个 x64 8个）盖了在叫完system以后会自动把其后的作为参数但是中间会需要加入参数中作为返回地址的数据（相当于传入四个字节换掉堆栈中的eip）（参数中字符串请用指针）。（当然64位中是不可以用的，因为64位中用寄存器传前七个参数） 64位自动对应p64 32位使用p32 sh.recvuntil(‘:‘)address = sh.recvuntil(‘?‘, drop=True)address = int(address, 16) 这样的方法可以获得写得起始点的地址，以确认shellcode的地址，免于重复运行计算‘sadsaddas’+’asdsadsda’ == ‘saddsdsdsdsa’ ‘asdasdasdachecksec 可以获得保护开启情况; break 0x400100 (b main):在 0x400100 处下断点tb一次性断点info b：查看断点信息delete [number]：删除断点watch (int *)0x08044530：在内存0x0804453处的数据改变时stopx /4xg \\$ebp：查看ebp开始的4个8字节内容（b：单字节，h：双字节，w：四字节，g：八字节；x：十六进制，s：字符串输出，i：反汇编，c：单字符）p $eax：输出eax的内容set \\$eax=4：修改变量值startls -f 可以展示隐藏文件 gdb-peda常用指令（机翻）c：继续运行r：重新开始运行ni：单步步过si：单步步入fini：运行至函数刚结束处return expression：将函数返回值指定为expressionbt：查看当前栈帧info f：查看当前栈帧context：查看运行上下文stack：查看当前堆栈call func：强制函数调用ropgagdet：找common ropvmmap：查看虚拟地址分布shellcode：搜索，生成shellcodeptype struct link_map：查看link_map定义p &amp;((struct link_map*)0)-&gt;l_info：查看l_info成员偏移libc ：打印libc的基址ld ：打印ld的基地址codebase ：打印代码段的基础heap ：打印堆的基础got ：打印全局偏移表信息dyn ：打印动态部分信息findcall ：找到一些函数调用bcall ：在某个函数调用中设置断点tls ：打印线程本地存储地址at ：按进程名称附加findsyscall ：找到系统调用fmtarg ：计算格式字符串的索引你需要停止有漏洞的printf。force ：计算力所在之处的nb。heapinfo ：打印堆的一些信息heapinfo（竞技场地址）默认是当前线程的舞台如果启用了tcache，它会显示tcache条目的信息heapinfoall ：打印堆的一些信息（所有线程）arenainfo ：打印所有竞技场的一些信息chunkinfo：打印块的信息chunkinfo（受害者的地址）chunkptr ：打印块的信息chunkptr（用户ptr的地址）mergeinfo ：打印合并信息mergeinfo（受f害者地址）printfastbin ：打印fastbin的一些信息tracemalloc on ：跟踪malloc并释放并检测到一些错误。你需要首先运行这个进程tracemalloc on，它会记录所有的malloc和free。你可以设置DEBUGpwngdb.py，比打印所有的malloc和免费的信息如screeshot。parseheap ：解析堆布局magic ：在glibc中打印有用的变量和函数fp ：显示FILE结构fp（文件的地址）fpchain：显示FILE的链接列表orange：中的测试house of orange条件_IO_flush_lockpz() : 调出此时的调试界面橙色（FILE的地址）ctrl + c停止调试 栈是从高向低发展栈溢出是从低向高溢出而单个数据内部则是从高向低按字节存放的而大多数的看内存的软件则是从低向高看的 ROPgadget 常用指令 binary ropchain 格式： ROPgadget --binary the_binary_elf ropchain 程序中已经用到的会被link进程序固定的plt表中 而没有被用到的也会被放在libc中，只需要无限leak即可找到system地址。 无限leak通常出现在栈溢出可以使程序重现进入该函数。","categories":[{"name":"从零开始的ctf之路","slug":"从零开始的ctf之路","permalink":"https://www.intmian.com/categories/从零开始的ctf之路/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.intmian.com/tags/pwn/"}]},{"title":"栈溢出指南","slug":"栈溢出指南","date":"2018-06-14T07:47:38.000Z","updated":"2018-07-01T07:59:13.859Z","comments":true,"path":"2018/06/14/栈溢出指南/","link":"","permalink":"https://www.intmian.com/2018/06/14/栈溢出指南/","excerpt":"一个关于栈溢出的指南","text":"一个关于栈溢出的指南 主题： 基本栈溢出 针对缓存区溢出防护的对策 shellcode栈溢出的最终目的是执行shellcode，夺取shell，因此本文将会从shellcode开始讲起。 shellcode通常是软件漏洞利用中的一小段代码，主要用于启动shell或干一些奇怪的事来让攻击控制正台机器 \\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\xb3\\x01\\x83\\xc4\\x1d\\x89\\xe1\\xb2\\x05\\xb0\\x04\\xcd\\x80\\xb0\\x01\\xb3\\x01\\xfe\\xcb\\xcd\\x80\\x46\\x55\\x43\\x4b\\x0a 这段代码的就是一段shellcode，其功能为 print(&quot;fuck&quot;); return 0; 当然，想要写一段shellcode也不是特别难，主要流程为 使用c语言描述shellcode要完成的逻辑功能将C语言翻译成汇编语言编译和测试测试通过后提取机器码 有两个书写shellcode时需要注意的问腿 由于缓存区漏洞是由于无长度限定的print家族（输入的是字符串，依靠’\\0’(ascii码为0)结尾）造成的，所以shellcode不能有0字节，否则会被截断。由于漏洞一般不能溢出无限大的字符串，所以不应该过于长。 shellcode一般达成以下功能 提升权限为root，即调用suid(0)启开bash，全面控制系统，即调用execve(“/bin/bash, NULL, NULL);打开网络端口，让攻击者连接该端口进行控制反向连接攻击者提供的端口，进行反向控制。（反弹shell） shellcode的编写虽然现在到处都可以找到现成的shellcode，但是我认为到还是有必要学习shellcode的编写。 下面我将阐述关于shellcode编写构成中的小问题的解决 虽然说由于栈溢出的漏洞多半是不能在构成参数的字节里中出现0。但是很明显，在代码中多半会出现0。 例如： MOV eax,0MOV eax,0x00000005(前三个字节都是零会把作为参数的字符串截断) 有以下两个方法可以解决这个问题，完成寄存器清零与给寄存器赋予一个极小的数。 xor eax eax 这样就可以将将eax置零还有cld可以将edx进行置零 如果需要将eax的值赋为0x5，不能直接写成mov eax, 0x05，因为它会生成机器码mov eax, 0x00000005，会有0填充（因为一个字节只能有8位你丢进去了32位那自然会有数据为零的内存基本单元出现）。 可以采用下面这个技巧： xor eax, eaxmov al, 0x05 虽然说在有些情况下，我们可以知道shellcode的绝对地址，从而跳转到shellcode处，但是在有些情况下shellcode中shellcode的位置是会变化的，这导致了shellcode所要填写的地址难以确定。但是我们可以使用另一个技巧来进行处理。例如call技术：call指令是相对转跳，但会在栈上压上绝对地址，然后再弹出就可以获取绝对地址 jmp short get_string code: pop eax ; 这里弹出的是call指令压栈的下条指令的地址，即&quot;hello world&quot;字符串的地址 get_string: call code data: db &apos;hello world&apos;, 0x0a linux系统调用是通过 int 0x80来陷入内核态的，在此过程中系统调用号通过eax来传递，而参数则是通过ebx，ecx,edx，esi来传递的。 在补充了这些基础知识后我们开始真正的着手开始编写shellcode,可以直接使用gcc对汇编文件.S进行编译链接，生成标准的可执行ELF文件，同时也是直接进行测试，但又一点不方便的是提取机械码很不方便。 为了提高提取机械码的效率，nasm编译器生成bin格式文件，而且没有其他东西，棒棒哒 例如我们想要书写一个夺取shell的shellcode，我们需要书写的核心代码是 char *argv[2]; argv[0] = &quot;/bin/sh&quot;; argv[1] = NULL;//指针数组需要以NULL结束不然会接着寻找接下去的指针 execve(&quot;/bin/sh&quot;, argv, NULL);//execve是内核级系统调用，第二个参数为数组指针，第三个参数为新的环境变量 excve的系统调用号为11 接下来我们将会将其转化为汇编代码（需要注意寄存器传参这一情况）先将字符串压到栈上 xor edx, edx push edx push 0x68732f2f push 0x6e69622f 这样子压入了”/bin/sh”，应该注意因为地址是从高地址向低地址蔓延的，所以需要从字符串的尾巴开始压起。 字符串在内存中的分布如下低 结束’\\0’↑↑ 第三部分↑↑ 第二部分高 第一部分换言之，栈顶指向的永远是一块数据的开始 由于我们需要让shellocde尽可能的短，所以我们不需要将没用的数据从堆栈中拿出，只需要简单的弃用就可以了 紧接着将这个字符串的指针也就是现在的栈顶取出,并压入栈中 mov ebx,esp push ebx 由于我们前面所对edx做的操作使得edx的值是0（即NULL）所以只需要 push edx 就把argv的数据全放在栈里了，然后 mov ecx,esp 最后把系统调用号即11赋给eax xor eax eax mov al 0xb 这样操作过后，eax为系统调用号，ebx为“/bin/sh”，ecx为argv，edx为新的环境变量，大功告成，紧接着我们 int 0x80 进行系统调用，大功告成。拼接过后的代码为 BITS 32 xor edx, edx push edx push 0x68732f2f push 0x6e69622f mov ebx, esp push edx push ebx mov ecx, esp xor eax, eax mov al, 0xb int 0x80 编译生成机器码 nasm -o shell2 shell2.s 生成的shell2文件为bin数据，全是机器码，没有任何格式数据，使用Linux命令转换成bash或者perl可输入的shellcode. $ od -t x1 shell2 | sed -e &apos;s/[0-7]*//&apos; | sed -e &apos;s/ /\\\\x/g&apos; 得到 \\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\x31\\xc0\\xb0\\x0b\\xcd 这就是我们的shellcode了 return-to-address有了以上的这些知识我们就可以使用最为简单的ret2addr攻击了。技术的核心是使用覆盖EIP来返回到确认地址，虽然十分简单粗暴，但是随着32位与64位的普及与alsr技术的普及逐渐失去功效，但是在某些特殊的场合这种技术仍然闪烁着光辉。千里之途，始于足下，下面让我们来学习这门技术吧。 首先我们先温习一遍内存中的数据存放 低 临时变量3 EBP-xxx↓↓ 临时变量2 EBP-xxx↓↓ 临时变量1 EBP-xxx↓↓ &lt;——EBP↓↓ EBP原值↓↓ EIP原值↓↓ 参数1↓↓ 参数2高 参数3 内存的操作数据的存放顺序是反过来的哦 这一种存储方式虽然高效但是会有一个致命的弱点，那就是内存中临时变量被溢出会把EIP盖掉，导致程序流就会走向你想要的任何地方（前提是没开canary等等的保护，绕过它们的方法以后会写）。 所以你需要知道shellcode在哪儿，才能精确的跳转至shellcode。这也就是为什么这种技术被称为热ret2addr。一般来说我们会在盖掉EIP的时候顺便在下面写下shellcode所以这个地址我们一般也是知道的。 在进行这种溢出的过程中我们一般需要确认EIP的地址才可以进行精准的覆盖，不至于让我们的程序滑到谁也不知道的地方去。 EIP的定位有两种方法：1.不停地向新开的程序里丢大小不同的垃圾最后当程序因为异常退出时就可以知道EIP的地址了。2.通过ida看当前栈帧里的内容决定丢多少垃圾进去。有些情况下会发生栈帧很大导致难以试出EIP或者ida分析不出的情况，可以考虑我的另一篇博客的所写的gdb-peda中的pattern大法。 exp的写法通用模板 # -*- coding:utf-8 -*- from pwn import * sh = remote(&quot;????&quot;,????) # 与服务器交互 junk = &apos;a&apos;*0x?? # 填充 fakebp = &apos;a&apos;*8# 淹没bp syscall = ????????????? payload = junk + fakebp + p64(syscall) # p64对整数进行打包 sh.send(payload) sh.interactive() # 直接反弹shell进行交互 更改？？？？？的内容就可以了。 return-to-register(绕过aslr)虽然说我们上文的技术十分有效，但是魔高一尺，道高一丈，安全技术人员发明了aslr技术对程序进行保护使得偏移量甚至达到2g，这让我们难以确认shellcode的真正位置。 aslr在linux系统上是一个编译选项而非像windows一样是一个链接选项。linux的alsr安全性高于windwos，但是会拖累程序的运行速度，所以aslr在linux上并非很普遍。 因为alsr会把栈的基址与栈帧随机掉，那么我们就不知道我们的shellcode会随机到哪里去了。而且确认EIP位置也成了一大难题，因为栈帧的变动会导致EIP变动。 但是真正的黑客从不畏惧艰难，勇于向不可能发起挑战，他们发明了ret2reg技术（当然nop-slide之类的技术也可以做到） 当然aslr+pie依然可以干掉这些大胆的黑客，当然这就是后话了。IDE的优化也可以，（笑 原理系统中的某一些函数会将当前栈帧的地址暴露出来，尤其是处理字符串等。有些情况下会把地址暴露到寄存器中。那么我们在写入shellcode后可以通过寄存器定位，然后在EIP中跳到寄存器位置加上相对偏移。 实现如果你一步步按这个方法进行操作的话，你会碰到一个问题。你需要进行 call xxx //jump xxx 但是它们在哪呢，我应该怎么样在程序中EIP中填写地址才能跳到那儿呢。aslr有一个特点可以帮助我们解决这个问题，那就是 前文提到使用 echo 2 &gt; /proc/sys/kernel/randomize_va_space 命令将地址混淆技术启用，但该技术对栈空间，堆地址和动态库加载空间都进行了混淆，唯独没有对程序做地址混淆。事实上Linux gcc编译器提供了-fPIE选项，但用它来编译，可使程序空间做地址混淆，造成整个进程地址混淆。但一般的开源软件和商用Linux发行商的服务进程并没有使用-fPIE进行安全增加，还是留下了可利用空间。注意到， stack2在编译时没有使用-fPIE选项。 我们可以通过objdump和grep命令来寻找call xxx相关的指令，然后在EIP中覆写这个地址，然后想办法把shellcode放到寄存器所在的地址去。然后就成功了。 局限如果程序中的寄存器指的地方你覆写不了（比如说在溢出点上面），或者下面的程序修改了这个寄存器的值，那这个方法就无能为力了。 return to libc(绕过NX)数据执行保护在linux环境下所说的NX与windows平台下的DEP是同一个东西，即数据执行保护。 其功能为通过将非代码段的代码设为不可执行，从而避免程序流被劫持到堆栈等位置的shellcode中。一旦EIP移动到非代码段中，CPU就会报异常，然后杀死这个进程。 在64位系统上，这个防护的实现主要通过内存页上的NX位。在windows环境下的32位系统则通过软件模拟的方式实现了这一防护。而linux的32位操作系统则没有这样的防护可以选择. 微软在windows XP系统上首先实现了这一防护。此外这一机制在windows上一般被称为DEP，而在linux上被称作NX。 原理虽然非代码段代码无法正常执行，但是我们可以把代码注入到现成的代码段。我们可以通过调用libc中的system函数来实现我们之前的shellcode中的功能。根据32位函数调用的规范，它会将堆栈中的数据当成参数。而堆栈的更改可以通过溢出等方式来实现（如果开了金丝雀防护的话需要从长计议）。 在linux中使用了libc的加强版本glibc。 利用因为我们需要伪造一个调用 所以我们的payload是A*n + system地址（对应EIP） + 返回地址 + “/bash/sh”(参数) 首先通过pattern生成一个足够大的字符串，定位EIP的位置与A的数量，这都是老生常谈的了。但是我们这次需要查看转储的核心文件core。 我们通过p system 暴露出libc中system函数的位置。 当然，如果你想要避免程序的非正常退出（瞎填的EIP使程序走向了奇怪的位置），你也可以在返回地址中填入exit的地址。 方法为p exit 巧妙地设计甚至可以绕过aslr因为不再需要定位shellcode。 局限如果你使用过这个方法的话，你就会发现这个方法是行不通的，因为现在有了一种新的保护机制叫做ASCII armoring来对抗ret2libc，它把libc中所有的地址的第一个字节都设为零，这就导致了在溢出时溢出内容会被截断，而开了NX以后又无法使用shellcode来绕过这一个限制。 本来应该在之后根据ASCII armoring的弱点讲ret2plt，但是在这之前还需要补充很多知识，才可以继续。故将新开一篇文章来对glibc中的一些特性进行讲解。","categories":[{"name":"从零开始的ctf之路","slug":"从零开始的ctf之路","permalink":"https://www.intmian.com/categories/从零开始的ctf之路/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://www.intmian.com/tags/pwn/"},{"name":"栈","slug":"栈","permalink":"https://www.intmian.com/tags/栈/"}]}]}